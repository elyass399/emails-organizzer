Directory structure:
└── emails-organizzer/
    ├── README.md
    ├── app.vue
    ├── components.json
    ├── nuxt.config.ts
    ├── package.json
    ├── tailwind.config.ts
    ├── test-imap-connection.js
    ├── tsconfig.json
    ├── assets/
    │   └── css/
    │       └── main.css
    ├── components/
    │   └── ui/
    │       ├── badge/
    │       │   ├── Badge.vue
    │       │   └── index.ts
    │       ├── button/
    │       │   ├── button.vue
    │       │   └── index.ts
    │       ├── card/
    │       │   ├── Card.vue
    │       │   ├── CardContent.vue
    │       │   ├── CardDescription.vue
    │       │   ├── CardFooter.vue
    │       │   ├── CardHeader.vue
    │       │   ├── CardTitle.vue
    │       │   └── index.ts
    │       ├── dialog/
    │       │   ├── Dialog.vue
    │       │   ├── DialogClose.vue
    │       │   ├── DialogContent.vue
    │       │   ├── DialogDescription.vue
    │       │   ├── DialogFooter.vue
    │       │   ├── DialogHeader.vue
    │       │   ├── DialogScrollContent.vue
    │       │   ├── DialogTitle.vue
    │       │   ├── DialogTrigger.vue
    │       │   └── index.ts
    │       ├── input/
    │       │   ├── index.ts
    │       │   └── Input.vue
    │       ├── label/
    │       │   ├── index.ts
    │       │   └── Label.vue
    │       ├── table/
    │       │   ├── index.ts
    │       │   ├── Table.vue
    │       │   ├── TableBody.vue
    │       │   ├── TableCaption.vue
    │       │   ├── TableCell.vue
    │       │   ├── TableEmpty.vue
    │       │   ├── TableFooter.vue
    │       │   ├── TableHead.vue
    │       │   ├── TableHeader.vue
    │       │   └── TableRow.vue
    │       ├── textarea/
    │       │   ├── index.ts
    │       │   └── Textarea.vue
    │       └── toast/
    │           ├── index.ts
    │           ├── Toast.vue
    │           ├── ToastAction.vue
    │           ├── ToastClose.vue
    │           ├── ToastDescription.vue
    │           ├── Toaster.vue
    │           ├── ToastProvider.vue
    │           ├── ToastTitle.vue
    │           ├── ToastViewport.vue
    │           └── use-toast.ts
    ├── lib/
    │   └── utils.ts
    ├── pages/
    │   └── index.vue
    ├── public/
    │   └── robots.txt
    └── server/
        ├── tsconfig.json
        ├── api/
        │   ├── clients.get.js
        │   ├── inbox.get.js
        │   ├── staff.get.js
        │   ├── staff.post.js
        │   ├── emails/
        │   │   ├── process.post.js
        │   │   └── webhook.post.js
        │   └── staff/
        │       └── [id].put.js
        ├── plugins/
        │   └── scheduler.js
        └── utils/
            ├── aiService.js
            ├── clientManager.js
            ├── emailSender.js
            ├── imapClient.js
            ├── mailProcessor.js
            ├── skillExtractor.js
            └── supabaseAdmin.js

================================================
FILE: README.md
================================================
# Nuxt Minimal Starter

Look at the [Nuxt documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.



================================================
FILE: app.vue
================================================
<!-- File: app.vue -->
<template>
  <div>
    <!-- Questo componente Ã¨ utile per l'accessibilitÃ , annuncia i cambi di pagina agli screen reader -->
    <NuxtRouteAnnouncer />
    
    <!-- Questo Ã¨ il componente piÃ¹ importante.
         Nuxt renderizzerÃ  qui il contenuto della pagina corrente (es. pages/index.vue) -->
    <NuxtPage />
  </div>
</template>

<style>
/* Aggiungiamo uno stile di base per lo sfondo, cosÃ¬ l'app non Ã¨ completamente bianca */
body {
  background-color: #f8f9fa; /* Un grigio molto chiaro */
  color: #212529; /* Un nero morbido */
}

/* Stili per il tema scuro (opzionale, ma buona pratica) */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #f9f6f6; /* Un grigio scuro */
    color: #060000; /* Un bianco sporco */
  }
}
</style>


================================================
FILE: components.json
================================================
{
  "$schema": "https://shadcn-vue.com/schema.json",
  "style": "default",
  "tailwind": { "config": "tailwind.config.ts", "css": "assets/css/main.css", "baseColor": "slate", "cssVariables": true },
  "framework": "nuxt",
  "aliases": { "components": "@/components", "utils": "@/lib/utils" }
}


================================================
FILE: nuxt.config.ts
================================================
// File: nuxt.config.ts

export default defineNuxtConfig({
  devtools: { enabled: true },
  
  modules: [
    '@nuxtjs/tailwindcss',
    '@nuxtjs/supabase',
    'shadcn-nuxt'
  ],

  supabase: {
    url: process.env.SUPABASE_URL,
    key: process.env.NUXT_PUBLIC_SUPABASE_KEY,
    redirect: false,
  },

  shadcn: {
    prefix: '',
    componentDir: './components/ui'
  },

  runtimeConfig: {
    googleApiKey: process.env.GOOGLE_API_KEY,
    supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,
    sendgridApiKey: process.env.SENDGRID_API_KEY, 
    senderEmail: process.env.SENDER_EMAIL,
    imapHost: process.env.IMAP_HOST,
    imapPort: parseInt(process.env.IMAP_PORT || '993'),
    imapUsername: process.env.IMAP_USERNAME,
    imapPassword: process.env.IMAP_PASSWORD,
    imapMailbox: process.env.IMAP_MAILBOX || 'INBOX',
    public: {
      supabaseUrl: process.env.SUPABASE_URL,
      supabaseAnonKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
    }
  },


})


================================================
FILE: package.json
================================================
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "NODE_TLS_REJECT_UNAUTHORIZED=0 nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@sendgrid/mail": "^8.1.5",
    "@vueuse/core": "^13.5.0",
    "autoprefixer": "^10.4.21",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.0",
    "lucide-vue-next": "^0.525.0",
    "mailparser": "^3.7.4",
    "node-cron": "^4.2.0",
    "node-imap": "^0.9.6",
    "nuxt": "^3.17.6",
    "radix-vue": "^1.9.17",
    "reka-ui": "^2.3.2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.11",
    "vue": "^3.5.17",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@nuxtjs/supabase": "^1.5.3",
    "@nuxtjs/tailwindcss": "^7.0.0-beta.0",
    "@tailwindcss/nesting": "^0.0.0-insiders.565cd3e",
    "postcss": "^8.5.6",
    "shadcn-nuxt": "^2.2.0"
  }
}


================================================
FILE: tailwind.config.ts
================================================
// tailwind.config.ts
import type { Config } from 'tailwindcss'
import animate from 'tailwindcss-animate'

export default {
  darkMode: ['class'],
  safelist: ['dark'],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        // --- MODIFICHE QUI ---
        // Forziamo background e foreground per i componenti Shadcn che usano --background
        background: 'hsl(var(--background))', // Questa Ã¨ la definizione standard
        foreground: 'hsl(var(--foreground))', // Questa Ã¨ la definizione standard


        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      borderRadius: {
        xl: 'calc(var(--radius) + 4px)',
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'collapsible-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-collapsible-content-height)' },
        },
        'collapsible-up': {
          from: { height: 'var(--radix-collapsible-content-height)' },
          to: { height: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'collapsible-down': 'collapsible-down 0.2s ease-in-out',
        'collapsible-up': 'collapsible-up 0.2s ease-in-out',
      },
    },
  },
  plugins: [animate],
} satisfies Config


================================================
FILE: test-imap-connection.js
================================================
// test-imap-connection.js - Moduli ES Syntax

import 'dotenv/config'; // Importa dotenv in modo che carichi le variabili

import Imap from 'node-imap';
import { simpleParser } from 'mailparser';

const config = {
  imapHost: process.env.IMAP_HOST,
  imapPort: parseInt(process.env.IMAP_PORT || '993'),
  imapUsername: process.env.IMAP_USERNAME,
  imapPassword: process.env.IMAP_PASSWORD,
  imapMailbox: process.env.IMAP_MAILBOX || 'INBOX',
};

console.log('--- IMAP Test Connection ---');
console.log('IMAP_HOST:', config.imapHost);
console.log('IMAP_PORT:', config.imapPort);
console.log('IMAP_USERNAME:', config.imapUsername);
// Non loggare la password per sicurezza

// Attiva il debug verboso di node-imap (puÃƒÂ² essere molto dettagliato)
// Imap.debug = console.log; // Mantienilo commentato per un output piÃƒÂ¹ pulito, riattivalo solo se necessario

console.log('IMAP Test Client Config being used:', {
  user: config.imapUsername,
  host: config.imapHost,
  port: config.imapPort,
  tls: true,
  tlsOptsRejectUnauthorized: false // Esplicito per il log
});

const imap = new Imap({
  user: config.imapUsername,
  password: config.imapPassword,
  host: config.imapHost,
  port: config.imapPort,
  tls: true,
  // *** ATTENZIONE CRITICA PER LA SICUREZZA IN PRODUZIONE ***
  // Questa opzione disabilita la verifica che il nome host del server IMAP
  // corrisponda al nome nel suo certificato SSL.
  // ÃƒË† NECESSARIO se il tuo provider (es. Shellrent) usa un certificato generico
  // (es. *.shared.hosting.com).
  // Espone a vulnerabilitÃƒÂ  Man-in-the-Middle (MITM) in produzione.
  // PER AMBIENTI DI PRODUZIONE, ASSICURATI DI AVERE UN CERTIFICATO SSL VALIDO
  // E Rimuovi O Imposta a `true`: `tlsOpts: { rejectUnauthorized: true }`
  tlsOpts: { rejectUnauthorized: false }
});

imap.once('ready', () => {
  console.log('IMAP: Connected successfully!');
  imap.openBox(config.imapMailbox, false, (err, box) => {
    if (err) {
      console.error('IMAP: Error opening mailbox:', err);
      imap.end();
      return;
    }
    console.log(`IMAP: Mailbox "${config.imapMailbox}" opened.`);

    imap.search(['UNSEEN'], (err, uids) => {
      if (err) {
        console.error('IMAP: Error searching for emails:', err);
        imap.end();
        return;
      }

      if (!uids || uids.length === 0) {
        console.log('IMAP: No new unseen emails.');
        imap.end();
        return;
      }

      console.log(`IMAP: Found ${uids.length} unseen emails. Fetching them.`);

      const f = imap.fetch(uids, { bodies: '' }); // Fetch the entire email body
      f.on('message', (msg, seqno) => {
        console.log(`IMAP: Processing message #${seqno} (UID: ${uids[seqno - 1]})`);
        let buffer = '';
        msg.on('body', (stream) => {
          stream.on('data', (chunk) => {
            buffer += chunk.toString('utf8');
          });
          stream.once('end', async () => {
            try {
              const parsed = await simpleParser(buffer);
              console.log(`  From: ${parsed.from?.text}`);
              console.log(`  Subject: ${parsed.subject}`);
              console.log(`  Date: ${parsed.date}`);
              // Puoi aggiungere parsed.text o parsed.html per vedere il corpo
            } catch (parseErr) {
              console.error('  Error parsing email:', parseErr);
            }
          });
        });
      });

      f.once('error', (fetchErr) => {
        console.error('IMAP: Fetch error:', fetchErr);
        imap.end();
      });

      f.once('end', () => {
        console.log('IMAP: Finished fetching messages.');
        imap.addFlags(uids, ['\\Seen'], (flagErr) => {
          if (flagErr) console.error('IMAP: Error marking emails as seen:', flagErr);
          console.log('IMAP: Emails marked as seen.');
          imap.end();
        });
      });
    });
  });
});

imap.once('error', (err) => {
  console.error('IMAP: Global error event:', err);
  imap.end();
});

imap.once('end', () => {
  console.log('IMAP: Connection gracefully closed.');
});

imap.connect();


================================================
FILE: tsconfig.json
================================================
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json"
}



================================================
FILE: assets/css/main.css
================================================
/* assets/css/main.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Aggiungi questa sezione per forzare lo sfondo bianco del DialogContent */
/* Questo sovrascrive lo stile di default di Shadcn per il DialogContent */
.dialog-content-force-white {
  background-color: white !important;
  color: black !important;
}

/* Forse necessario anche per il tema scuro, se dark mode Ã¨ attivo */
.dark .dialog-content-force-white {
  background-color: white !important;
  color: black !important;
}


================================================
FILE: components/ui/badge/Badge.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { type BadgeVariants, badgeVariants } from '.'
import { cn } from '@/lib/utils'
interface Props { variant?: BadgeVariants['variant']; class?: HTMLAttributes['class'] }
const props = defineProps<Props>()
</script>
<template><div :class="cn(badgeVariants({ variant }), props.class)"><slot /></div></template>


================================================
FILE: components/ui/badge/index.ts
================================================
import { type VariantProps, cva } from 'class-variance-authority'
export { default as Badge } from './Badge.vue'
export const badgeVariants = cva('inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2', {
    variants: { 
        variant: { 
            default: 'border-transparent bg-primary text-primary-foreground hover:bg-primary/80', 
            secondary: 'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80', 
            destructive: 'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80', 
            outline: 'text-foreground border-input',
            // RIMOSSE LE VARIANTI PERSONALIZZATE PER I BADGE DEGLI UFFICI
        } 
    },
    defaultVariants: { variant: 'default' },
})
export type BadgeVariants = VariantProps<typeof badgeVariants>


================================================
FILE: components/ui/button/button.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { Primitive, type PrimitiveProps } from 'radix-vue'
import { type ButtonVariants, buttonVariants } from '.'
import { cn } from '@/lib/utils'

// MODIFICA QUI: Rimuovi 'extends PrimitiveProps' e definisci esplicitamente 'as' e 'asChild'
interface Props {
  variant?: ButtonVariants['variant'];
  size?: ButtonVariants['size'];
  class?: HTMLAttributes['class'];
  as?: PrimitiveProps['as']; // Usa il tipo da PrimitiveProps per 'as'
  asChild?: PrimitiveProps['asChild']; // Usa il tipo da PrimitiveProps per 'asChild'
}

const props = withDefaults(defineProps<Props>(), { 
  as: 'button', // Default tag HTML
  asChild: false // Default a non renderizzare come child
})
</script>
<template>
  <Primitive :as="props.as" :as-child="props.asChild" :class="cn(buttonVariants({ variant, size }), props.class)"><slot /></Primitive>
</template>


================================================
FILE: components/ui/button/index.ts
================================================
import { type VariantProps, cva } from 'class-variance-authority'
export { default as Button } from './button.vue'
export const buttonVariants = cva('inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50', {
    variants: {
        variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
        // NUOVA VARIANTE: Sfondo nero, testo bianco
        black: 'bg-black text-white hover:bg-black/90',
        },
        size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
        },
    },
    defaultVariants: { variant: 'default', size: 'default' },
})
export type ButtonVariants = VariantProps<typeof buttonVariants>


================================================
FILE: components/ui/card/Card.vue
================================================
<template><div :class="cn('rounded-lg border bg-card text-card-foreground shadow-sm', props.class)"><slot /></div></template>
<script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; 
const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardContent.vue
================================================
<template><div :class="cn('p-6 pt-0', props.class)"><slot /></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardDescription.vue
================================================
<template><p :class="cn('text-sm text-muted-foreground', props.class)"><slot /></p></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardFooter.vue
================================================
<template><div :class="cn('flex items-center p-6 pt-0', props.class)"><slot /></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardHeader.vue
================================================
<template><div :class="cn('flex flex-col space-y-1.5 p-6', props.class)"><slot /></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardTitle.vue
================================================
<template><h3 :class="cn('text-2xl font-semibold leading-none tracking-tight', props.class)"><slot /></h3></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/index.ts
================================================
export { default as Card } from './Card.vue'
export { default as CardHeader } from './CardHeader.vue'
export { default as CardTitle } from './CardTitle.vue'
export { default as CardDescription } from './CardDescription.vue'
export { default as CardContent } from './CardContent.vue'
export { default as CardFooter } from './CardFooter.vue'


================================================
FILE: components/ui/dialog/Dialog.vue
================================================
<script setup lang="ts">
import { DialogRoot, type DialogRootEmits, type DialogRootProps, useForwardPropsEmits } from 'radix-vue'
const props = defineProps</* @vue-ignore */ DialogRootProps>() // Aggiungi qui
const emits = defineEmits<DialogRootEmits>()
const forwarded = useForwardPropsEmits(props, emits)
</script>
<template><DialogRoot v-bind="forwarded"><slot /></DialogRoot></template>


================================================
FILE: components/ui/dialog/DialogClose.vue
================================================
<script setup lang="ts">
import { DialogClose, type DialogCloseProps } from 'radix-vue' // <-- CAMBIATO DA reka-ui a radix-vue

const props = defineProps</* @vue-ignore */ DialogCloseProps>()
</script>

<template>
  <DialogClose v-bind="props">
    <slot />
  </DialogClose>
</template>


================================================
FILE: components/ui/dialog/DialogContent.vue
================================================
<script setup lang="ts">
import { type HTMLAttributes, computed } from 'vue'
import { DialogClose, DialogContent, type DialogContentEmits, type DialogContentProps, DialogOverlay, DialogPortal, useForwardPropsEmits } from 'radix-vue'
import { X } from 'lucide-vue-next'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ DialogContentProps & { class?: HTMLAttributes['class'] }>()
const emits = defineEmits<DialogContentEmits>()
const delegatedProps = computed(() => { const { class: _, ...delegated } = props; return delegated })
const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>
<template>
  <DialogPortal>
    <DialogOverlay class="fixed inset-0 z-50 bg-black/80" />
    <!-- CLASSE AGGIORNATA QUI: 'max-w-lg' DEVE ESSERE STATO RIMOSSO -->
    <DialogContent v-bind="forwarded" :class="cn('fixed left-1/2 top-1/2 z-50 grid w-full -translate-x-1/2 -translate-y-1/2 gap-4 border bg-white !important p-6 shadow-lg duration-200 sm:rounded-lg dark:bg-white !important dark:text-black !important', props.class)">
      <slot />
      <DialogClose class="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
        <X class="h-4 w-4" />
        <span class="sr-only">Close</span>
      </DialogClose>
    </DialogContent>
  </DialogPortal>
</template>


================================================
FILE: components/ui/dialog/DialogDescription.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { DialogDescription, type DialogDescriptionProps } from 'radix-vue'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ DialogDescriptionProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui
</script>
<template><DialogDescription :class="cn('text-sm text-muted-foreground', props.class)" v-bind="props"><slot /></DialogDescription></template>


================================================
FILE: components/ui/dialog/DialogFooter.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'
const props = defineProps<{ class?: HTMLAttributes['class'] }>()
</script>
<template><div :class="cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', props.class)"><slot /></div></template>


================================================
FILE: components/ui/dialog/DialogHeader.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'
const props = defineProps<{ class?: HTMLAttributes['class'] }>()
</script>
<template><div :class="cn('flex flex-col space-y-1.5 text-center sm:text-left', props.class)"><slot /></div></template>


================================================
FILE: components/ui/dialog/DialogScrollContent.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { X } from 'lucide-vue-next'
import {
  DialogClose,
  DialogContent, // Questo ora viene da radix-vue!
  type DialogContentEmits,
  type DialogContentProps,
  DialogOverlay, // Questo ora viene da radix-vue!
  DialogPortal, // Questo ora viene da radix-vue!
  useForwardPropsEmits,
} from 'radix-vue' // <-- CAMBIATO DA reka-ui a radix-vue
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ DialogContentProps & { class?: HTMLAttributes['class'] }>()
const emits = defineEmits<DialogContentEmits>()
const delegatedProps = reactiveOmit(props, 'class')
const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <DialogPortal>
    <DialogOverlay
      class="fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
    >
      <DialogContent
        :class="
          cn(
            'relative z-50 grid w-full max-w-lg my-8 gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full',
            props.class,
          )
        "
        v-bind="forwarded"
        @pointer-down-outside="(event) => {
          const originalEvent = event.detail.originalEvent;
          const target = originalEvent.target as HTMLElement;
          if (originalEvent.offsetX > target.clientWidth || originalEvent.offsetY > target.clientHeight) {
            event.preventDefault();
          }
        }"
      >
        <slot />

        <DialogClose
          class="absolute top-4 right-4 p-0.5 transition-colors rounded-md hover:bg-secondary"
        >
          <X class="w-4 h-4" />
          <span class="sr-only">Close</span>
        </DialogClose>
      </DialogContent>
    </DialogOverlay>
  </DialogPortal>
</template>


================================================
FILE: components/ui/dialog/DialogTitle.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { DialogTitle, type DialogTitleProps } from 'radix-vue'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ DialogTitleProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui
</script>
<template><DialogTitle v-bind="props" :class="cn('text-lg font-semibold leading-none tracking-tight', props.class)"><slot /></DialogTitle></template>


================================================
FILE: components/ui/dialog/DialogTrigger.vue
================================================
<script setup lang="ts">
import { DialogTrigger, type DialogTriggerProps } from 'radix-vue'
const props = defineProps</* @vue-ignore */ DialogTriggerProps>() // Aggiungi qui
</script>
<template><DialogTrigger v-bind="props"><slot /></DialogTrigger></template>


================================================
FILE: components/ui/dialog/index.ts
================================================
// File: components/ui/dialog/index.ts
export { default as Dialog } from './Dialog.vue'
export { default as DialogClose } from './DialogClose.vue'
export { default as DialogContent } from './DialogContent.vue'
export { default as DialogDescription } from './DialogDescription.vue'
export { default as DialogFooter } from './DialogFooter.vue'
export { default as DialogHeader } from './DialogHeader.vue'
export { default as DialogScrollContent } from './DialogScrollContent.vue'
export { default as DialogTitle } from './DialogTitle.vue'
export { default as DialogTrigger } from './DialogTrigger.vue'


================================================
FILE: components/ui/input/index.ts
================================================
export { default as Input } from './Input.vue'



================================================
FILE: components/ui/input/Input.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { useVModel } from '@vueuse/core'
import { cn } from '@/lib/utils'
const props = defineProps<{ defaultValue?: string | number; modelValue?: string | number; class?: HTMLAttributes['class'] }>()
const emits = defineEmits<{ (e: 'update:modelValue', payload: string | number): void }>()
const modelValue = useVModel(props, 'modelValue', emits, { passive: true, defaultValue: props.defaultValue })
</script>
<template><input v-model="modelValue" :class="cn('flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50', props.class)"></template>


================================================
FILE: components/ui/label/index.ts
================================================
// File: components/ui/label/index.ts
export { default as Label } from './Label.vue'


================================================
FILE: components/ui/label/Label.vue
================================================
<script setup lang="ts">
import { type HTMLAttributes, type LabelHTMLAttributes } from 'vue'
import { Label, type LabelProps } from 'radix-vue'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ LabelProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui
</script>
<template><Label :class="cn('text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70', props.class)"><slot /></Label></template>


================================================
FILE: components/ui/table/index.ts
================================================
// File: components/ui/table/index.ts

export { default as Table } from './Table.vue'
export { default as TableHeader } from './TableHeader.vue'
export { default as TableBody } from './TableBody.vue' // Assicurati che sia .vue
export { default as TableRow } from './TableRow.vue'
export { default as TableHead } from './TableHead.vue'
export { default as TableCell } from './TableCell.vue'


================================================
FILE: components/ui/table/Table.vue
================================================
<template><div class="relative w-full overflow-auto"><table :class="cn('w-full caption-bottom text-sm', props.class)"><slot /></table></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableBody.vue
================================================
<template><tbody :class="cn('[&_tr:last-child]:border-0', props.class)"><slot /></tbody></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableCaption.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'

const props = defineProps<{
  class?: HTMLAttributes['class']
}>()
</script>

<template>
  <caption :class="cn('mt-4 text-sm text-muted-foreground', props.class)">
    <slot />
  </caption>
</template>



================================================
FILE: components/ui/table/TableCell.vue
================================================
<template><td :class="cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', props.class)"><slot /></td></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableEmpty.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { cn } from '@/lib/utils'
import TableCell from './TableCell.vue'
import TableRow from './TableRow.vue'

const props = withDefaults(defineProps<{
  class?: HTMLAttributes['class']
  colspan?: number
}>(), {
  colspan: 1,
})

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <TableRow>
    <TableCell
      :class="
        cn(
          'p-4 whitespace-nowrap align-middle text-sm text-foreground',
          props.class,
        )
      "
      v-bind="delegatedProps"
    >
      <div class="flex items-center justify-center py-10">
        <slot />
      </div>
    </TableCell>
  </TableRow>
</template>



================================================
FILE: components/ui/table/TableFooter.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'

const props = defineProps<{
  class?: HTMLAttributes['class']
}>()
</script>

<template>
  <tfoot :class="cn('border-t bg-muted/50 font-medium [&>tr]:last:border-b-0', props.class)">
    <slot />
  </tfoot>
</template>



================================================
FILE: components/ui/table/TableHead.vue
================================================
<template><th :class="cn('h-8 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0', props.class)"><slot /></th></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableHeader.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'

const props = defineProps<{
  class?: HTMLAttributes['class']
}>()
</script>

<template>
  <th :class="cn('h-8 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5', props.class)">
    <slot />
  </th>
</template>


================================================
FILE: components/ui/table/TableRow.vue
================================================
<template><tr :class="cn('border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted', props.class)"><slot /></tr></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/textarea/index.ts
================================================
// File: components/ui/textarea/index.ts
export { default as Textarea } from './Textarea.vue'


================================================
FILE: components/ui/textarea/Textarea.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { useVModel } from '@vueuse/core'
import { cn } from '@/lib/utils'
const props = defineProps<{ class?: HTMLAttributes['class']; defaultValue?: string | number; modelValue?: string | number }>()
const emits = defineEmits<(e: 'update:modelValue', payload: string | number) => void>()
const modelValue = useVModel(props, 'modelValue', emits, { passive: true, defaultValue: props.defaultValue })
</script>
<template><textarea v-model="modelValue" :class="cn('flex min-h-20 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50', props.class)" /></template>


================================================
FILE: components/ui/toast/index.ts
================================================
import type { ToastRootProps } from 'reka-ui'
import type { Component, HTMLAttributes, VNode } from 'vue' // Aggiunto VNode

export { default as Toast } from './Toast.vue'
export { default as ToastAction } from './ToastAction.vue'
export { default as ToastClose } from './ToastClose.vue'
export { default as ToastDescription } from './ToastDescription.vue'
export { default as Toaster } from './Toaster.vue'
export { default as ToastProvider } from './ToastProvider.vue'
export { default as ToastTitle } from './ToastTitle.vue'
export { default as ToastViewport } from './ToastViewport.vue'
export { toast, useToast } from './use-toast'

import { cva, type VariantProps } from 'class-variance-authority'

// MODIFICA QUI: Estendi da ToastRootProps e aggiungi le proprietÃƒÂ  che vengono passate dal `use-toast`
export interface ToastProps extends /* @vue-ignore */ ToastRootProps {
  class?: HTMLAttributes['class']
  variant?: ToastVariants['variant']
  // ProprietÃ  aggiunte per compatibilitÃ  con ToasterToast in use-toast.ts
  title?: string
  description?: string | VNode | (() => VNode) // Deve essere compatibile con StringOrVNode
  action?: Component // Componente per l'azione del toast
}

export const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--reka-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--reka-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
                    'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

type ToastVariants = VariantProps<typeof toastVariants>

// La definizione ToastProps qui sotto ÃƒÂ¨ duplicata e meno specifica,
// manteniamo quella superiore che ÃƒÂ¨ piÃƒÂ¹ completa.
// export interface ToastProps extends ToastRootProps {
//   class?: HTMLAttributes['class']
//   variant?: ToastVariants['variant']
//   onOpenChange?: ((value: boolean) => void) | undefined
// }


================================================
FILE: components/ui/toast/Toast.vue
================================================
<script setup lang="ts">
import { reactiveOmit } from '@vueuse/core'
import { ToastRoot, type ToastRootEmits, useForwardPropsEmits } from 'reka-ui'
import { cn } from '@/lib/utils'
import { type ToastProps, toastVariants } from '.'

const props = defineProps</* @vue-ignore */ ToastProps>() // Aggiungi qui

const emits = defineEmits<ToastRootEmits>()

// Passa solo le props che ToastRoot di reka-ui si aspetta, escludendo quelle aggiuntive per use-toast
const delegatedProps = reactiveOmit(props, 'class', 'title', 'description', 'action')

const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <ToastRoot
    v-bind="forwarded"
    :class="cn(toastVariants({ variant }), props.class)"
    @update:open="props.onOpenChange"
  >
    <slot />
  </ToastRoot>
</template>


================================================
FILE: components/ui/toast/ToastAction.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastAction, type ToastActionProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastActionProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastAction v-bind="delegatedProps" :class="cn('inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive', props.class)">
    <slot />
  </ToastAction>
</template>



================================================
FILE: components/ui/toast/ToastClose.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { X } from 'lucide-vue-next'
import { ToastClose, type ToastCloseProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastCloseProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastClose v-bind="delegatedProps" :class="cn('absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600', props.class)">
    <X class="h-4 w-4" />
  </ToastClose>
</template>



================================================
FILE: components/ui/toast/ToastDescription.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastDescription, type ToastDescriptionProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastDescriptionProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastDescription :class="cn('text-sm opacity-90', props.class)" v-bind="delegatedProps">
    <slot />
  </ToastDescription>
</template>



================================================
FILE: components/ui/toast/Toaster.vue
================================================
<script setup lang="ts">
import { isVNode } from 'vue'
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from '.'
import { useToast } from './use-toast'

const { toasts } = useToast()
</script>

<template>
  <ToastProvider>
    <Toast v-for="toast in toasts" :key="toast.id" v-bind="toast">
      <div class="grid gap-1">
        <ToastTitle v-if="toast.title">
          {{ toast.title }}
        </ToastTitle>
        <template v-if="toast.description">
          <ToastDescription v-if="isVNode(toast.description)">
            <component :is="toast.description" />
          </ToastDescription>
          <ToastDescription v-else>
            {{ toast.description }}
          </ToastDescription>
        </template>
        <ToastClose />
      </div>
      <component :is="toast.action" />
    </Toast>
    <ToastViewport />
  </ToastProvider>
</template>



================================================
FILE: components/ui/toast/ToastProvider.vue
================================================
<script setup lang="ts">
import { ToastProvider, type ToastProviderProps } from 'reka-ui'

const props = defineProps</* @vue-ignore */ ToastProviderProps>() // Aggiungi qui
</script>

<template>
  <ToastProvider v-bind="props">
    <slot />
  </ToastProvider>
</template>



================================================
FILE: components/ui/toast/ToastTitle.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastTitle, type ToastTitleProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastTitleProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastTitle v-bind="delegatedProps" :class="cn('text-sm font-semibold [&+div]:text-xs', props.class)">
    <slot />
  </ToastTitle>
</template>



================================================
FILE: components/ui/toast/ToastViewport.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastViewport, type ToastViewportProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastViewportProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastViewport
    v-bind="delegatedProps"
    :class="cn('fixed top-0 right-0 z-[100] flex max-h-screen w-full flex-col p-4 md:max-w-[420px]', props.class)"
  />
</template>


================================================
FILE: components/ui/toast/use-toast.ts
================================================
// components/ui/toast/use-toast.ts

import type { Component, VNode } from 'vue'
import type { ToastProps } from '.'
import { computed, ref } from 'vue'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 3000 // MODIFICA QUI: Da 1000000 a 3000

export type StringOrVNode =
  | string
  | VNode
  | (() => VNode)

type ToasterToast = ToastProps & {
  id: string
  title?: string
  description?: StringOrVNode
  action?: Component
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
    type: ActionType['ADD_TOAST']
    toast: ToasterToast
  }
  | {
    type: ActionType['UPDATE_TOAST']
    toast: Partial<ToasterToast>
  }
  | {
    type: ActionType['DISMISS_TOAST']
    toastId?: ToasterToast['id']
  }
  | {
    type: ActionType['REMOVE_TOAST']
    toastId?: ToasterToast['id']
  }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

function addToRemoveQueue(toastId: string) {
  if (toastTimeouts.has(toastId))
    return

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: actionTypes.REMOVE_TOAST,
      toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

const state = ref<State>({
  toasts: [],
})

function dispatch(action: Action) {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      state.value.toasts = [action.toast, ...state.value.toasts].slice(0, TOAST_LIMIT)
      break

    case actionTypes.UPDATE_TOAST:
      state.value.toasts = state.value.toasts.map(t =>
        t.id === action.toast.id ? { ...t, ...action.toast } : t,
      )
      break

    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      }
      else {
        state.value.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      state.value.toasts = state.value.toasts.map(t =>
        t.id === toastId || toastId === undefined
          ? {
              ...t,
              open: false,
            }
          : t,
      )
      break
    }

    case actionTypes.REMOVE_TOAST:
      if (action.toastId === undefined)
        state.value.toasts = []
      else
        state.value.toasts = state.value.toasts.filter(t => t.id !== action.toastId)

      break
  }
}

function useToast() {
  return {
    toasts: computed(() => state.value.toasts),
    toast,
    dismiss: (toastId?: string) => dispatch({ type: actionTypes.DISMISS_TOAST, toastId }),
  }
}

type Toast = Omit<ToasterToast, 'id'>

function toast(props: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: actionTypes.UPDATE_TOAST,
      toast: { ...props, id },
    })

  const dismiss = () => dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id })

  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open: boolean) => {
        if (!open)
          dismiss()
      },
    },
  })

  return {
    id,
    dismiss,
    update,
  }
}

export { toast, useToast }


================================================
FILE: lib/utils.ts
================================================
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'
export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)) }


================================================
FILE: pages/index.vue
================================================
<!-- File: pages/index.vue -->
<script setup>
import { ref, onMounted, computed, reactive } from 'vue';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

// Importa i componenti Dialog, Label, Input, Textarea necessari
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogClose } from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/components/ui/toast/use-toast';
import { Toaster } from '@/components/ui/toast';

// Importa le icone necessarie per il refresh e i bottoni staff
import { RefreshCw, Users, Edit, List, AlertTriangle } from 'lucide-vue-next';


// --- STATO DELLA PAGINA ---
const processedEmails = ref([]);
const selectedEmailContent = ref(null);
const showContentModal = ref(false);
const isLoadingEmails = ref(true); // Rinominato per chiarezza

// Stato per la modale di AGGIUNTA staff
const showAddStaffDialog = ref(false);
const newStaffForm = reactive({
  name: '',
  email: '',
  text_skills: '',
});

// Stato e dati per la modale di MODIFICA staff centralizzata
const showUpdateStaffDialog = ref(false);
const allStaffMembers = ref([]); // Lista completa dei dipendenti/uffici per la dropdown
const selectedStaffIdToUpdate = ref(null); // ID del dipendente selezionato nella dropdown

const updateStaffForm = reactive({ // Form per la modifica del testo delle skills
  text_skills: '',
});

// NUOVO STATO per la modale di VISUALIZZAZIONE staff
const showViewStaffDialog = ref(false); // NUOVO STATO PER LA NUOVA MODALE
const isLoadingStaff = ref(true); // Stato di caricamento per la lista staff

// Stato e dati per la modale di VISUALIZZAZIONE clienti
const showViewClientsDialog = ref(false);
const allClients = ref([]); // Lista completa dei clienti
const isLoadingClients = ref(true);


// Computed per ottenere il nome e l'email del dipendente selezionato nella modale di modifica
const currentSelectedStaff = computed(() => {
  return allStaffMembers.value.find(staff => staff.id === selectedStaffIdToUpdate.value) || {};
});


const activeFilter = ref('all');

// Toast per notifiche
const { toast } = useToast();

const filteredEmails = computed(() => {
  if (!processedEmails.value || !Array.isArray(processedEmails.value)) {
    return [];
  }
  return processedEmails.value;
});


// --- FUNZIONI PRINCIPALI ---
const fetchProcessedEmails = async () => {
  isLoadingEmails.value = true;
  try {
    const data = await $fetch('/api/inbox');
    processedEmails.value = data || [];
  }
  catch (error) {
    console.error("Impossibile caricare la posta smistata:", error);
    toast({
      title: 'Errore',
      description: 'Impossibile caricare lo storico delle email.',
      variant: 'destructive',
    });
    processedEmails.value = [];
  }
  finally {
    isLoadingEmails.value = false;
  }
};

// Funzione: Carica la lista completa dello staff
const fetchAllStaff = async () => {
  isLoadingStaff.value = true; // Aggiunto per gestire lo stato di caricamento della lista staff
  try {
    const data = await $fetch('/api/staff');
    allStaffMembers.value = data || [];
    // Imposta il primo staff come selezionato di default per la modale di modifica, se esiste
    if (allStaffMembers.value.length > 0) {
      selectedStaffIdToUpdate.value = allStaffMembers.value[0].id;
      updateStaffForm.text_skills = allStaffMembers.value[0].text_skills;
    } else {
      selectedStaffIdToUpdate.value = null;
      updateStaffForm.text_skills = '';
    }
  } catch (error) {
    console.error("Impossibile caricare la lista staff:", error);
    toast({
      title: 'Errore',
      description: 'Impossibile caricare la lista dei dipendenti/uffici.',
      variant: 'destructive',
    });
    allStaffMembers.value = [];
  } finally {
    isLoadingStaff.value = false;
  }
};

// NUOVA FUNZIONE: Carica la lista completa dei clienti
const fetchAllClients = async () => {
  isLoadingClients.value = true;
  try {
    const data = await $fetch('/api/clients'); // Chiamata al nuovo endpoint
    allClients.value = data || [];
  } catch (error) {
    console.error("Impossibile caricare la lista clienti:", error);
    toast({
      title: 'Errore',
      description: 'Impossibile caricare la lista dei clienti.',
      variant: 'destructive',
    });
    allClients.value = [];
  } finally {
    isLoadingClients.value = false;
  }
};


// Funzione per gestire la selezione di un dipendente nella dropdown di modifica
const handleStaffSelectionChange = () => {
  const selectedStaff = allStaffMembers.value.find(staff => staff.id === selectedStaffIdToUpdate.value);
  if (selectedStaff) {
    updateStaffForm.text_skills = selectedStaff.text_skills;
  } else {
    updateStaffForm.text_skills = '';
  }
};


const viewEmailContent = (email) => {
  selectedEmailContent.value = email;
  showContentModal.value = true;
};

const addStaff = async () => {
  console.log('Frontend: addStaff function called on submit.');
  console.log('Frontend: newStaffForm data:', {
    name: newStaffForm.name,
    email: newStaffForm.email,
    text_skills: newStaffForm.text_skills
  });

  if (!newStaffForm.name || !newStaffForm.email || !newStaffForm.text_skills || newStaffForm.text_skills.trim() === '') {
    toast({
      title: 'Errore',
      description: 'Nome, email e descrizione competenze sono campi obbligatori e non possono essere vuoti.',
      variant: 'destructive',
    });
    console.error('Frontend: Errore: Campi addStaff mancanti/vuoti.');
    return;
  }

  try {
    const response = await $fetch('/api/staff', {
      method: 'POST',
      body: newStaffForm,
    });

    if (response.status === 'success') {
      toast({
        title: 'Successo!',
        description: 'Dipendente aggiunto e salvato nel database.',
      });
      showAddStaffDialog.value = false;
      Object.assign(newStaffForm, { name: '', email: '', text_skills: '' });
      await fetchProcessedEmails();
      await fetchAllStaff(); // Aggiorna la lista staff per tutte le modali
      console.log('Frontend: Aggiunta staff completata con successo.');
    } else {
      toast({
        title: 'Errore',
        description: response.message || 'Errore durante l\'aggiunta del dipendente.',
        variant: 'destructive',
      });
      console.error('Frontend: Errore risposta API addStaff:', response.message);
    }
  } catch (error) {
    console.error('Frontend: Errore durante l\'aggiunta del dipendente:', error);
    toast({
      title: 'Errore',
      description: error.data?.statusMessage || 'Si Ã¨ verificato un errore imprevisto.',
      variant: 'destructive',
    });
  }
};

// Funzione per aprire la modale di AGGIORNAMENTO STAFF centralizzata
const openCentralUpdateStaffDialog = async () => {
  await fetchAllStaff(); // Carica sempre la lista piÃƒÂ¹ recente
  showUpdateStaffDialog.value = true;
};

// NUOVA FUNZIONE: per aprire la modale di VISUALIZZAZIONE STAFF
const openViewStaffDetailsDialog = async () => {
  await fetchAllStaff(); // Carica sempre la lista piÃƒÂ¹ recente
  showViewStaffDialog.value = true;
};

// NUOVA FUNZIONE: per aprire la modale di VISUALIZZAZIONE CLIENTI
const openViewClientsDialog = async () => {
  await fetchAllClients(); // Carica la lista piÃƒÂ¹ recente dei clienti
  showViewClientsDialog.value = true;
};


const updateStaff = async () => {
  console.log('Frontend: updateStaff function called.');
  console.log('Frontend: selectedStaffIdToUpdate:', selectedStaffIdToUpdate.value);
  console.log('Frontend: updateStaffForm.text_skills:', updateStaffForm.text_skills);

  if (!selectedStaffIdToUpdate.value) {
    toast({
      title: 'Errore',
      description: 'Nessun dipendente selezionato per l\'aggiornamento.',
      variant: 'destructive',
    });
    console.error('Frontend: Errore: Nessun dipendente selezionato.');
    return;
  }

  if (!updateStaffForm.text_skills || updateStaffForm.text_skills.trim() === '') {
    toast({
      title: 'Errore',
      description: 'Il campo "Descrizione Competenze" non puÃ² essere vuoto.',
    });
    console.error('Frontend: Errore: Il campo Descrizione Competenze ÃƒÂ¨ vuoto.');
    return;
  }

  console.log('updateStaff function called for ID:', selectedStaffIdToUpdate.value);
  try {
    console.log('Frontend: Tentativo di inviare richiesta PUT per aggiornare staff...');
    console.log('Frontend: URL della richiesta:', `/api/staff/${selectedStaffIdToUpdate.value}`);
    console.log('Frontend: Body della richiesta:', { text_skills: updateStaffForm.text_skills });

    const response = await $fetch(`/api/staff/${selectedStaffIdToUpdate.value}`, {
      method: 'PUT',
      body: {
        text_skills: updateStaffForm.text_skills, // Inviamo solo il campo modificabile
      },
    });

    if (response.status === 'success') {
      toast({
        title: 'Successo!',
        description: 'Competenze del dipendente aggiornate e ricalcolate.',
      });
      showUpdateStaffDialog.value = false;
      await fetchProcessedEmails(); // Ricarica tutte le email per riflettere le modifiche
      await fetchAllStaff(); // Ricarica la lista staff per sicurezza
      console.log('Frontend: Aggiornamento staff completato con successo.');
    } else {
      toast({
        title: 'Errore',
        description: response.message || 'Errore durante l\'aggiornamento delle competenze.',
        variant: 'destructive',
      });
      console.error('Frontend: Errore risposta API:', response.message);
    }
  } catch (error) {
    console.error('Frontend: Errore durante l\'aggiornamento delle competenze:', error);
    toast({
      title: 'Errore',
      description: error.data?.statusMessage || 'Si Ã¨ verificato un errore imprevisto.',
      variant: 'destructive',
    });
  }
};


// --- FUNZIONI UTILI PER LA GRAFICA E I BADGE ---
const formatDate = (dateString) => {
  if (!dateString) return 'N/D';
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return 'Data non valida';
  const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
  return date.toLocaleString('it-IT', options);
};

const getConfidenceVariant = (score) => {
  if (score === null || score === undefined) return 'secondary';
  if (score >= 0.8) return 'default';
  if (score >= 0.5) return 'secondary';
  return 'destructive';
};

const getStatusLabel = (status) => {
  switch (status) {
    case 'new': return 'Nuova';
    case 'analyzed': return 'Analizzata';
    case 'forwarded': return 'Inoltrata';
    case 'manual_review': return 'Revisione Manuale';
    case 'ai_error': return 'Errore AI';
    case 'forward_error': return 'Errore Inoltro';
    case 'processing_error': return 'Errore Elaborazione';
    case 'processed_follow_up': return 'Dati Cliente Aggiornati';
    default: return status;
  }
};

const getStaffBadgeVariant = (staffName) => {
  return 'secondary';
};

const getRowUrgencyClass = (isUrgent) => {
  return isUrgent ? 'border-l-4 border-red-500 bg-red-50' : '';
};

const getUrgencyBadge = (isUrgent) => {
  if (isUrgent) {
    return {
      text: 'URGENTE',
      variant: 'destructive',
      icon: AlertTriangle
    };
  }
  return null;
};

// Funzione per formattare lo stato del follow-up email
const formatFollowUpStatus = (client) => {
  if (client.follow_up_email_sent) {
    return `Inviata il ${formatDate(client.follow_up_sent_at)}`;
  }
  const hasAllInfo = client.name && client.phone_number && client.city;
  if (hasAllInfo) {
    return 'Completi';
  }
  return 'Mancanti';
};

// --- HOOK ---
onMounted(async () => {
  await fetchProcessedEmails();
});
</script>

<template>
  <div class="container mx-auto p-4 md:p-8 space-y-8">
    <Toaster />

    <h1 class="text-2xl font-bold mb-4">Gestione Email Intelligente</h1>

    <!-- Pulsanti "Aggiungi", "Modifica", "Visualizza Dipendenti" e "Visualizza Clienti" (allineati a destra) -->
    <div class="flex justify-end gap-2 mb-4">
      <Button variant="outline" @click="showAddStaffDialog = true" class="shrink-0">
        <Users class="h-4 w-4 mr-2" />
        Aggiungi Dipendente/Ufficio
      </Button>
      <Button variant="outline" @click="openCentralUpdateStaffDialog" class="shrink-0">
        <Edit class="h-4 w-4 mr-2" />
        Modifica Dipendente/Ufficio
      </Button>
      <!-- NUOVO BOTTONE PER VISUALIZZARE STAFF -->
      <Button variant="outline" @click="openViewStaffDetailsDialog" class="shrink-0">
        <List class="h-4 w-4 mr-2" />
        Visualizza Dipendenti/Uffici
      </Button>
      <!-- NUOVO BOTTONE PER VISUALIZZARE CLIENTI -->
      <Button variant="outline" @click="openViewClientsDialog" class="shrink-0">
        <List class="h-4 w-4 mr-2" />
        Visualizza Clienti
      </Button>
    </div>

    <Card>
      <CardHeader>
        <CardTitle>Posta Smistata dall'AI</CardTitle>
        <CardDescription>Elenco delle email analizzate e assegnate a un dipartimento responsabile.</CardDescription>
      </CardHeader>
      <CardContent>
        <!-- TOOLBAR: SOLO PULSANTE AGGIORNA ALLINEATO A DESTRA (FILTRI RIMOSSI) -->
        <div class="flex justify-end mb-4">
          <Button variant="outline" @click="fetchProcessedEmails" :disabled="isLoadingEmails" class="shrink-0">
            <RefreshCw class="h-4 w-4 mr-2" />
            Aggiorna
          </Button>
        </div>

        <!-- Stato di Caricamento/Vuoto della Tabella -->
        <div v-if="isLoadingEmails" class="text-center py-16">
          <p class="text-muted-foreground">Caricamento storico email...</p>
        </div>
        <div v-else-if="filteredEmails.length > 0">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead class="text-left">Mittente</TableHead>
                <TableHead class="text-center">Assegnato A</TableHead>
                <TableHead class="text-center">Confidenza AI</TableHead>
                <TableHead class="text-center">Stato</TableHead>
                <TableHead class="text-right">Ricevuta il</TableHead>
                <TableHead class="text-center">Contenuto</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              <TableRow
                v-for="email in filteredEmails"
                :key="email.id"
                :class="getRowUrgencyClass(email.is_urgent)"
              >
                <TableCell class="font-medium text-left">
                  <div class="flex items-center gap-2">
                    <AlertTriangle v-if="email.is_urgent" class="h-4 w-4 text-red-600" title="Email Urgente" />
                    <div>
                      <div>{{ email.sender }}</div>
                      <div class="text-xs text-muted-foreground truncate max-w-xs" :title="email.subject">{{ email.subject }}</div>
                    </div>
                  </div>
                </TableCell>
                <TableCell class="text-center">
                  <Badge :variant="getStaffBadgeVariant(email.staff?.name)">
                    {{ email.staff?.name || 'Non Assegnato' }}
                  </Badge>
                </TableCell>
                <TableCell class="text-center">
                  <Badge :variant="getConfidenceVariant(email.ai_confidence_score)">
                    {{ email.ai_confidence_score !== null && email.ai_confidence_score !== undefined ? (email.ai_confidence_score * 100).toFixed(0) + '%' : 'N/D' }}
                  </Badge>
                </TableCell>
                <TableCell class="text-center">
                  <div class="flex flex-col items-center gap-1">
                    <span>{{ getStatusLabel(email.status) }}</span>
                    <Badge v-if="getUrgencyBadge(email.is_urgent)" :variant="getUrgencyBadge(email.is_urgent).variant">
                      {{ getUrgencyBadge(email.is_urgent).text }}
                    </Badge>
                  </div>
                </TableCell>
                <TableCell class="text-right">{{ formatDate(email.created_at) }}</TableCell>
                <TableCell class="text-center">
                   <Button
                     @click="viewEmailContent(email)"
                     size="sm"
                     variant="black"
                   >
                     Visualizza
                   </Button>
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </div>
        <div v-else class="text-center py-16">
          <p class="text-muted-foreground">Nessuna email trovata per il filtro selezionata.</p>
          <p class="text-muted-foreground text-sm mt-2">Le email vengono elaborate automaticamente ogni 5 minuti.</p>
        </div>
      </CardContent>
    </Card>

    <!-- Modale per visualizzare contenuto email -->
<Dialog :open="showContentModal" @update:open="showContentModal = false">
  <DialogContent v-if="selectedEmailContent" class="dialog-content-force-white">
      <DialogHeader>
          <DialogTitle>{{ selectedEmailContent.subject }}</DialogTitle>
          <DialogDescription>Da: {{ selectedEmailContent.sender }}</DialogDescription>
      </DialogHeader>
      <div class="py-4 whitespace-pre-wrap text-sm max-h-96 overflow-y-auto">
          {{ selectedEmailContent.body_text || "Corpo dell'email non disponibile." }}

          <!-- BLOCCO PER GLI ALLEGATI -->
          <div v-if="selectedEmailContent.attachments && selectedEmailContent.attachments.length > 0" class="mt-4 border-t pt-4">
            <h4 class="font-semibold mb-2">Allegati:</h4>
            <ul class="list-disc pl-5">
              <li v-for="attachment in selectedEmailContent.attachments" :key="attachment.public_url || attachment.filename">
                <a :href="attachment.public_url" target="_blank" class="text-blue-600 hover:underline">
                  {{ attachment.filename }} ({{ (attachment.size / 1024).toFixed(2) }} KB)
                </a>
              </li>
            </ul>
          </div>
          <!-- Icona di Urgenza nella Modale -->
          <div v-if="selectedEmailContent.is_urgent" class="mt-4 flex items-center text-red-600 font-semibold">
            <AlertTriangle class="h-5 w-5 mr-2" />
            <span>Questa email ÃƒÂ¨ stata classificata come URGENTE dall'AI.</span>
          </div>
      </div>
      <DialogFooter>
          <Button @click="showContentModal = false" variant="outline">Chiudi</Button>
      </DialogFooter>
  </DialogContent>
</Dialog>

    <!-- Modale per Aggiungere Nuovo Dipendente/Ufficio -->
    <Dialog :open="showAddStaffDialog" @update:open="showAddStaffDialog = $event">
      <DialogContent class="dialog-content-force-white">
        <DialogHeader>
          <DialogTitle>Aggiungi Nuovo Dipendente/Ufficio</DialogTitle>
          <DialogDescription>
            Inserisci i dettagli del nuovo membro dello staff o del nuovo ufficio.
          </DialogDescription>
        </DialogHeader>
        <form @submit.prevent="addStaff">
          <div class="grid gap-4 py-4">
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="name" class="text-right">
                Nome Ufficio / Dipendente
              </Label>
              <Input id="name" v-model="newStaffForm.name" required class="col-span-3" />
            </div>
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="email" class="text-right">
                Email
              </Label>
              <Input id="email" type="email" v-model="newStaffForm.email" required class="col-span-3" />
            </div>
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="textSkills" class="text-right">
                Descrizione Competenze
              </Label>
              <Textarea id="textSkills" v-model="newStaffForm.text_skills" required class="col-span-3" />
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" @click="showAddStaffDialog = false">Annulla</Button>
            <Button type="submit">Aggiungi</Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>

    <!-- Modale per Aggiornare Competenze Dipendente (Centralizzata) -->
    <Dialog :open="showUpdateStaffDialog" @update:open="showUpdateStaffDialog = $event">
      <DialogContent class="dialog-content-force-white">
        <DialogHeader>
          <DialogTitle>Modifica Competenze Dipendente/Ufficio</DialogTitle>
          <DialogDescription>
            Seleziona un dipendente/ufficio per aggiornare la descrizione delle sue competenze.
          </DialogDescription>
        </DialogHeader>
        <form @submit.prevent="updateStaff">
          <div class="grid gap-4 py-4">
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="staffSelect" class="text-right">
                Seleziona Dipendente/Ufficio
              </Label>
              <select 
                id="staffSelect" 
                v-model="selectedStaffIdToUpdate" 
                @change="handleStaffSelectionChange"
                class="col-span-3 flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                required
              >
                <option v-if="allStaffMembers.length === 0" value="" disabled>Nessun dipendente disponibile</option>
                <option 
                  v-for="staff in allStaffMembers" 
                  :key="staff.id" 
                  :value="staff.id"
                >
                  {{ staff.name }} ({{ staff.email }})
                </option>
              </select>
            </div>

            <!-- Campi nome e email visualizzati per il dipendente selezionato -->
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="selectedName" class="text-right">
                Nome
              </Label>
              <Input id="selectedName" :model-value="currentSelectedStaff.name" readonly class="col-span-3 bg-gray-100 text-gray-600" />
            </div>
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="selectedEmail" class="text-right">
                Email
              </Label>
              <Input id="selectedEmail" :model-value="currentSelectedStaff.email" readonly class="col-span-3 bg-gray-100 text-gray-600" />
            </div>

            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="updateTextSkills" class="text-right">
                Descrizione Competenze
              </Label>
              <Textarea id="updateTextSkills" v-model="updateStaffForm.text_skills" required class="col-span-3" />
            </div>

            <!-- Optional: Mostra le skills estratte dall'AI dopo l'update per verifica -->
            <div v-if="currentSelectedStaff.skills && currentSelectedStaff.skills.length > 0" class="grid grid-cols-4 items-center gap-4">
              <Label class="text-right">Skills estratte (AI)</Label>
              <div class="col-span-3 flex flex-wrap gap-2">
                <Badge v-for="skill in currentSelectedStaff.skills" :key="skill" variant="secondary">
                  {{ skill }}
                </Badge>
              </div>
            </div>
             <div v-else class="grid grid-cols-4 items-center gap-4 text-sm text-muted-foreground">
              <span class="col-span-4 text-right">Nessuna skill estratta (o ancora da elaborare).</span>
            </div>

          </div>
          <DialogFooter>
            <Button type="button" variant="outline" @click="showUpdateStaffDialog = false">Annulla</Button>
            <Button type="submit" :disabled="!selectedStaffIdToUpdate">Salva Modifiche</Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>

    <!-- NUOVA MODALE PER VISUALIZZARE DIPENDENTI/UFFICI -->
    <Dialog :open="showViewStaffDialog" @update:open="showViewStaffDialog = $event">
      <DialogContent class="dialog-content-force-white max-w-7xl w-11/12">
        <DialogHeader>
          <DialogTitle>Elenco Dipendenti/Uffici</DialogTitle>
          <DialogDescription>
            Dettagli di tutti i membri dello staff e delle loro competenze.
          </DialogDescription>
        </DialogHeader>

        <div v-if="isLoadingStaff" class="text-center py-8">
          <p class="text-muted-foreground">Caricamento lista dipendenti...</p>
        </div>
        <div v-else-if="allStaffMembers.length > 0" class="max-h-[500px] overflow-y-auto overflow-x-auto">
          <Table class="min-w-full">
            <TableHeader>
              <TableRow>
                <TableHead class="w-[20%] min-w-[150px]">Nome Ufficio / Dipendente</TableHead>
                <TableHead class="w-[25%] min-w-[200px]">Email</TableHead>
                <TableHead class="w-[55%] min-w-[300px]">Descrizione Competenze</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              <TableRow v-for="staff in allStaffMembers" :key="staff.id">
                <TableCell class="font-medium">{{ staff.name }}</TableCell>
                <TableCell class="break-all">{{ staff.email }}</TableCell>
                <TableCell class="text-sm">
                  <div class="whitespace-normal break-words">{{ staff.text_skills }}</div>
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </div>
        <div v-else class="text-center py-8">
          <p class="text-muted-foreground">Nessun dipendente/ufficio configurato.</p>
        </div>

        <DialogFooter>
          <Button type="button" variant="outline" @click="showViewStaffDialog = false">Chiudi</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>


    <!-- NUOVA MODALE PER VISUALIZZARE CLIENTI -->
    <Dialog :open="showViewClientsDialog" @update:open="showViewClientsDialog = $event">
      <DialogContent class="dialog-content-force-white max-w-7xl w-11/12">
        <DialogHeader>
          <DialogTitle>Elenco Clienti</DialogTitle>
          <DialogDescription>
            Dettagli di tutti i clienti e lo stato delle loro informazioni.
          </DialogDescription>
        </DialogHeader>

        <div v-if="isLoadingClients" class="text-center py-8">
          <p class="text-muted-foreground">Caricamento lista clienti...</p>
        </div>
        <div v-else-if="allClients.length > 0" class="max-h-[500px] overflow-y-auto overflow-x-auto">
          <Table class="min-w-full">
            <TableHeader>
              <TableRow>
                <TableHead class="w-[20%] min-w-[150px]">Email</TableHead>
                <TableHead class="w-[20%] min-w-[150px]">Nome</TableHead>
                <TableHead class="w-[15%] min-w-[120px]">Telefono</TableHead>
                <TableHead class="w-[15%] min-w-[120px]">Comune</TableHead>
                <TableHead class="w-[30%] min-w-[200px]">Follow-up</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              <TableRow v-for="client in allClients" :key="client.id">
                <TableCell class="font-medium break-all">{{ client.email }}</TableCell>
                <TableCell>{{ client.name || 'N/D' }}</TableCell>
                <TableCell>{{ client.phone_number || 'N/D' }}</TableCell>
                <TableCell>{{ client.city || 'N/D' }}</TableCell>
                <TableCell>{{ formatFollowUpStatus(client) }}</TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </div>
        <div v-else class="text-center py-8">
          <p class="text-muted-foreground">Nessun cliente trovato.</p>
        </div>

        <DialogFooter>
          <Button type="button" variant="outline" @click="showViewClientsDialog = false">Chiudi</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>


  </div>
</template>


================================================
FILE: public/robots.txt
================================================
User-Agent: *
Disallow:



================================================
FILE: server/tsconfig.json
================================================
{
  "extends": "../.nuxt/tsconfig.server.json"
}



================================================
FILE: server/api/clients.get.js
================================================
// server/api/clients.get.js

import { defineEventHandler } from 'h3';
import { getSupabaseAdminClient } from '../utils/supabaseAdmin'; // Usa il client admin per sicurezza e consistenza

export default defineEventHandler(async (event) => {
  const supabaseAdmin = getSupabaseAdminClient();

  const { data, error } = await supabaseAdmin
    .from('clients')
    .select('id, created_at, email, name, phone_number, city, follow_up_email_sent, follow_up_sent_at') // Seleziona tutte le colonne pertinenti
    .order('created_at', { ascending: false }); // Ordina per data di creazione, i piÃƒÂ¹ recenti prima

  if (error) {
    console.error('Supabase clients fetch error:', error.message);
    throw createError({ statusCode: 500, statusMessage: error.message });
  }

  return data;
});


================================================
FILE: server/api/inbox.get.js
================================================
// File: server/api/inbox.get.js

import { defineEventHandler } from 'h3';
import { serverSupabaseClient } from '#supabase/server';

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event);

  const { data, error } = await supabase
    .from('incoming_emails') // Assicurati sia il nome corretto (con underscore o trattino se quotato)
    .select(`
  id, created_at, sender, subject, body_text, status, is_urgent,
  ai_confidence_score, ai_reasoning,
  staff:assigned_to_staff_id ( id, name, email, text_skills, skills ),
  attachments:email-attachments ( filename, mimetype, size, public_url )
`)
    .order('created_at', { ascending: false });

  if (error) {
      console.error('API inbox.get.js error:', error.message);
      throw createError({ statusCode: 500, statusMessage: error.message });
  }
  return data;
});


================================================
FILE: server/api/staff.get.js
================================================
// server/api/staff.get.js

import { defineEventHandler } from 'h3';
import { serverSupabaseClient } from '#supabase/server';

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event);

  const { data, error } = await supabase
    // Modifica qui: seleziona le nuove colonne
    .from('staff')
    .select('id, name, email, text_skills, skills') // Aggiungi text_skills e skills
    .order('name', { ascending: true });

  if (error) {
    console.error('Supabase staff fetch error:', error.message);
    throw createError({ statusCode: 500, statusMessage: error.message });
  }

  return data;
});


================================================
FILE: server/api/staff.post.js
================================================
// server/api/staff.post.js

import { defineEventHandler, readBody, createError } from 'h3';
import { getSupabaseAdminClient } from '../utils/supabaseAdmin';
import { extractSkillsFromText } from '../utils/skillExtractor'; // Importa il nuovo servizio

export default defineEventHandler(async (event) => {
  const supabaseAdmin = getSupabaseAdminClient();
  const body = await readBody(event);
  const { name, email, text_skills } = body; 

  console.log('API Staff POST: Ricevuti dati ->', { name, email, text_skills: text_skills ? text_skills.substring(0, 50) + '...' : 'N/A' });

  if (!name || !email || !text_skills || text_skills.trim() === '') { // Aggiorna la validazione
    throw createError({ statusCode: 400, statusMessage: 'Nome, email e descrizione competenze sono campi obbligatori e non possono essere vuoti.' });
  }

  try {
    // Estrai le skills dall'AI
    console.log('API Staff POST: Chiamata a skillExtractor per text_skills:', text_skills ? text_skills.substring(0, 50) + '...' : 'N/A');
    const skills = await extractSkillsFromText(text_skills);
    console.log('API Staff POST: Skills estratte dall\'AI:', skills);

    const { data, error } = await supabaseAdmin
      .from('staff')
      .insert({
        name: name,
        email: email,
        text_skills: text_skills, // Inserisci il testo originale
        skills: skills,          // Inserisci l'array estratto
      })
      .select()
      .single();

    if (error) {
      console.error('API Supabase staff insert error:', error.message);
      
      let statusMessage = `Errore durante l'aggiunta del dipendente: ${error.message}`;
      if (error.code === '23505' && error.message.includes('staff_email_key')) {
        statusMessage = 'Un dipendente/ufficio con questa email esiste giÃƒÂ . Si prega di usare un\'email unica.';
      }
      
      throw createError({ statusCode: 500, statusMessage: statusMessage });
    }

    console.log('API Staff POST: Dipendente aggiunto con successo:', data);
    return { status: 'success', message: 'Dipendente aggiunto con successo!', data: data };
  } catch (e) {
    console.error('Errore nel processare la richiesta POST per staff:', e);
    throw createError({ statusCode: e.statusCode || 500, statusMessage: e.statusMessage || 'Errore interno del server.' });
  }
});


================================================
FILE: server/api/emails/process.post.js
================================================
// File: server/api/emails/process.post.js

import { defineEventHandler, readBody, createError, setResponseStatus } from 'h3';
import { getSupabaseAdminClient } from '../../utils/supabaseAdmin'; // CAMBIATO: Usa il client Admin
import { analyzeEmailWithAI } from '../../utils/aiService'; // Funzione centralizzata per l'analisi AI
import { sendEmail } from '../../utils/emailSender';     // Funzione centralizzata per l'invio email

export default defineEventHandler(async (event) => {
  const supabaseAdmin = getSupabaseAdminClient(); // Usa il client Supabase Admin
  const body = await readBody(event);
  const { sender, subject, body_text } = body;

  console.log('API Manual Process POST: Ricevuti dati ->', { sender, subject: subject ? subject.substring(0, 50) + '...' : 'N/A' });

  if (!sender || !subject || !body_text) {
    throw createError({ statusCode: 400, statusMessage: 'Mittente, oggetto o corpo email mancanti.' });
  }

  let emailRecordId = null; // ID dell'email nel DB, per aggiornamenti successivi

  try {
    // 1. Salva l'email nel database con stato 'new'
    const { data: savedEmail, error: saveError } = await supabaseAdmin.from('incoming_emails').insert([{ // CAMBIATO: usa supabaseAdmin
        sender: sender,
        subject: subject,
        body_text: body_text,
        // body_html: null, // Non abbiamo HTML dal form manuale, quindi null
        status: 'new',
    }]).select().single();

    if (saveError) {
        console.error('API Supabase save error (process.post):', saveError.message);
        throw createError({ statusCode: 500, statusMessage: `Errore durante il salvataggio dell'email: ${saveError.message}` });
    }
    emailRecordId = savedEmail.id;
    console.log(`API Manual Process POST: Manual email saved to DB with ID: ${emailRecordId}`);

    // 2. Analisi AI
    console.log(`API Manual Process POST: Avvio analisi AI per email ID ${emailRecordId}...`);
    const aiResult = await analyzeEmailWithAI(sender, subject, body_text);
    console.log(`API Manual Process POST: Risultato analisi AI per ID ${emailRecordId}:`, aiResult);
    
    // 3. Aggiorna l'email nel DB con i risultati dell'AI
    const newStatus = aiResult.assigned_to_staff_id ? 'analyzed' : 'manual_review';
    const { error: updateError } = await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
        assigned_to_staff_id: aiResult.assigned_to_staff_id,
        ai_confidence_score: aiResult.ai_confidence_score,
        ai_reasoning: aiResult.ai_reasoning,
        status: newStatus,
    }).eq('id', emailRecordId);

    if (updateError) {
        console.error('API Supabase AI update error (process.post):', updateError.message);
        throw createError({ statusCode: 500, statusMessage: `Errore durante l'aggiornamento AI dell'email: ${updateError.message}` });
    }
    console.log(`API Manual Process POST: AI analysis updated for manual email ID ${emailRecordId}. Assigned to staff: ${aiResult.assigned_to_staff_id || 'N/A'}`);

    // 4. Se l'AI ha assegnato e trovato un'email, inoltra l'email
    let assignedStaffMember = null;
    if (aiResult.assigned_to_staff_id && aiResult.assignedStaffEmail) {
        try {
            console.log(`API Manual Process POST: Tentativo di inoltro email ID ${emailRecordId} a ${aiResult.assignedStaffEmail}...`);
            await sendEmail(
                aiResult.assignedStaffEmail,
                sender.split('<')[0].trim() || sender, // Nome dal mittente originale
                sender, // Email mittente originale
                subject,
                body_text, // Invia il testo originale
                aiResult.ai_reasoning
            );
            // Aggiorna lo stato a 'forwarded'
            await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
                status: 'forwarded'
            }).eq('id', emailRecordId);

            assignedStaffMember = { 
                id: aiResult.assigned_to_staff_id, 
                name: aiResult.assignedStaffName, 
                email: aiResult.assignedStaffEmail 
            };
            console.log(`API Manual Process POST: Manual email ID ${emailRecordId} successfully forwarded to ${aiResult.assignedStaffEmail}`);

        } catch (forwardError) {
            console.error('API Error during manual email forwarding (process.post):', forwardError);
            // Aggiorna lo stato a 'forward_error'
            await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
                status: 'forward_error'
            }).eq('id', emailRecordId);
            throw createError({ statusCode: 500, statusMessage: `Errore durante l'inoltro dell'email: ${forwardError.message}` });
        }
    } else {
        console.warn(`API Manual Process POST: Manual email ID ${emailRecordId} not assigned by AI or missing staff email. Status set to 'manual_review'.`);
        // Lo stato ÃƒÂ¨ giÃƒÂ  'manual_review' dal passo precedente
    }

    setResponseStatus(event, 200);
    return { 
      status: 'success',
      message: 'Email processata e assegnata con successo.', 
      assignment: assignedStaffMember, 
      emailRecord: savedEmail 
    };

  } catch (error) {
    console.error('Unhandled error in process.post.js:', error);
    // Se c'ÃƒÂ¨ un errore e emailRecordId ÃƒÂ¨ noto, prova ad aggiornare lo stato a 'processing_error'
    if (emailRecordId) {
        await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
            status: 'processing_error',
            // error_message: error.message // Se hai un campo per i messaggi di errore
        }).eq('id', emailRecordId);
    }
    setResponseStatus(event, error.statusCode || 500);
    return { 
        status: 'error',
        message: error.statusMessage || 'Si ÃƒÂ¨ verificato un errore imprevisto.',
        details: error.message // Per dettagli nell'errore frontend
    };
  }
});


================================================
FILE: server/api/emails/webhook.post.js
================================================
// File: server/api/emails/webhook.post.js

import { defineEventHandler, readBody, setResponseStatus } from 'h3';
import { getSupabaseAdminClient } from '../../utils/supabaseAdmin'; // CAMBIATO: Usa il client Admin
import { analyzeEmailWithAI } from '../../utils/aiService'; // Funzione centralizzata per l'analisi AI
import { sendEmail } from '../../utils/emailSender';     // Funzione centralizzata per l'invio email

export default defineEventHandler(async (event) => {
    const supabaseAdmin = getSupabaseAdminClient(); // Usa il client Supabase Admin
    const payload = await readBody(event); // Il payload del webhook (es. da SendGrid Inbound Parse)

    // Estrai i dati dal payload (questi campi sono comuni nei webhook di parsing email)
    const senderRaw = payload.from || ''; 
    const senderEmail = senderRaw.match(/<(.+)>/)?.[1] || senderRaw; // Estrae solo l'email da "Nome <email@example.com>"
    const senderName = senderRaw.replace(/<.+>/, '').trim() || senderEmail;
    const subject = payload.subject || 'Nessun Oggetto';
    const body_text = payload.text || payload.html || 'Corpo email vuoto.';
    const body_html = payload.html || null;

    console.log('Webhook POST: Ricevuti dati ->', { senderEmail, subject: subject ? subject.substring(0, 50) + '...' : 'N/A' });


    if (!senderEmail) {
      console.warn("Webhook ricevuto senza mittente valido. Ignorato.");
      setResponseStatus(event, 200); // Importante rispondere 200 OK per evitare re-invii da webhook
      return { status: "ignored", message: "Payload incompleto, email ignorata."};
    }

    let emailRecordId = null;

    try {
        // 1. Salva l'email nel database con stato 'new'
        const { data: savedEmail, error: saveError } = await supabaseAdmin.from('incoming_emails').insert([{ // CAMBIATO: usa supabaseAdmin
            sender: senderEmail,
            subject: subject, 
            body_text: body_text, 
            body_html: body_html,
            status: 'new',
        }]).select().single();
        
        if (saveError) {
            console.error('Webhook Supabase save error (webhook.post):', saveError.message);
            throw new Error(`Errore Supabase (insert): ${saveError.message}`); // Rilancia per cattura successiva
        }
        emailRecordId = savedEmail.id;
        console.log(`Webhook POST: Email saved to DB with ID: ${emailRecordId}`);

        // 2. Analisi AI
        console.log(`Webhook POST: Avvio analisi AI per email ID ${emailRecordId}...`);
        const aiResult = await analyzeEmailWithAI(senderEmail, subject, body_text);
        console.log(`Webhook POST: Risultato analisi AI per ID ${emailRecordId}:`, aiResult);

        // 3. Aggiorna l'email nel DB con i risultati dell'AI
        const newStatus = aiResult.assigned_to_staff_id ? 'analyzed' : 'manual_review';
        const { error: updateError } = await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
            assigned_to_staff_id: aiResult.assigned_to_staff_id,
            ai_confidence_score: aiResult.ai_confidence_score,
            ai_reasoning: aiResult.ai_reasoning,
            status: newStatus,
        }).eq('id', emailRecordId);

        if (updateError) {
            console.error('Webhook Supabase AI update error (webhook.post):', updateError.message);
            throw new Error(`Errore Supabase (update AI): ${updateError.message}`);
        }
        console.log(`Webhook POST: AI analysis updated for webhook email ID ${emailRecordId}. Assigned to staff: ${aiResult.assigned_to_staff_id || 'N/A'}`);

        // 4. Inoltra l'email al dipendente corretto
        if (aiResult.assigned_to_staff_id && aiResult.assignedStaffEmail) {
            try {
                console.log(`Webhook POST: Tentativo di inoltro email ID ${emailRecordId} a ${aiResult.assignedStaffEmail}...`);
                await sendEmail(
                    aiResult.assignedStaffEmail,
                    senderName,
                    senderEmail,
                    subject,
                    body_text, // O body_html se preferisci, a seconda di sendEmail
                    aiResult.ai_reasoning
                );
                // Aggiorna lo stato a 'forwarded'
                await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
                    status: 'forwarded'
                }).eq('id', emailRecordId);
                console.log(`Webhook POST: Email ID ${emailRecordId} successfully forwarded to ${aiResult.assignedStaffEmail}`);

            } catch (forwardError) {
                console.error('Webhook Error during email forwarding (webhook.post):', forwardError);
                // Aggiorna lo stato a 'forward_error'
                await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
                    status: 'forward_error'
                }).eq('id', emailRecordId);
                throw forwardError; // Rilancia l'errore per il catch generale
            }
        } else {
            console.warn(`Webhook POST: Email ID ${emailRecordId} not assigned by AI or missing staff email. Status set to 'manual_review'.`);
            // Lo stato ÃƒÂ¨ giÃƒÂ  'manual_review'
        }

        setResponseStatus(event, 200); // Sempre 200 OK per i webhook che hanno elaborato il messaggio
        return { status: 'success', message: `Email da ${senderEmail} processata e assegnata.` };

    } catch (error) {
        console.error('Unhandled error in webhook.post.js:', error);
        // Se c'ÃƒÂ¨ un errore e emailRecordId ÃƒÂ¨ noto, prova ad aggiornare lo stato a 'processing_error'
        if (emailRecordId) {
            await supabaseAdmin.from('incoming_emails').update({ // CAMBIATO: usa supabaseAdmin
                status: 'processing_error',
                // error_message: error.message // Se hai un campo per i messaggi di errore
            }).eq('id', emailRecordId);
        }
        setResponseStatus(event, 200); // **IMPORTANTE:** Rispondi sempre 200 OK ai webhook per evitare re-invii continui, anche in caso di errore interno.
        return { status: 'error', message: `Errore interno durante l'elaborazione del webhook: ${error.message}` };
    }
});


================================================
FILE: server/api/staff/[id].put.js
================================================
// server/api/staff/[id].put.js

import { defineEventHandler, readBody, createError, getRouterParams } from 'h3';
import { getSupabaseAdminClient } from '../../utils/supabaseAdmin';
import { extractSkillsFromText } from '../../utils/skillExtractor'; // GiÃƒÆ’Ã‚Â  esistente

export default defineEventHandler(async (event) => {
    console.log('*** API STAFF PUT: ENDPOINT RAGGIUNTO ***');
  const supabaseAdmin = getSupabaseAdminClient(); // Usa il client Supabase Admin
  const { id } = getRouterParams(event); // Ottiene l'ID dalla URL
  const body = await readBody(event);
  const { text_skills } = body; // Ci aspettiamo solo text_skills dal frontend

  console.log('API Staff PUT: Ricevuti dati per ID:', id, '-> text_skills:', text_skills ? text_skills.substring(0, 50) + '...' : 'N/A');


  if (!id) {
    throw createError({ statusCode: 400, statusMessage: 'ID dipendente mancante.' });
  }
  if (text_skills === undefined || text_skills === null || text_skills.trim() === '') {
    throw createError({ statusCode: 400, statusMessage: 'Il campo "Descrizione Competenze" non puÃƒÆ’Ã‚Â² essere vuoto.' });
  }

  try {
    // 1. Estrai le skills aggiornate dall'AI
    console.log('API Staff PUT: Chiamata a skillExtractor per text_skills:', text_skills ? text_skills.substring(0, 50) + '...' : 'N/A');
    const skills = await extractSkillsFromText(text_skills);
    console.log('API Staff PUT: Skills estratte dall\'AI:', skills);

    // 2. Aggiorna il record nel database
    const { data, error } = await supabaseAdmin
      .from('staff')
      .update({
        text_skills: text_skills,
        skills: skills,
      })
      .eq('id', id)
      .select() // Per ottenere il record aggiornato
      .single();

    if (error) {
      console.error('API Supabase staff update error:', error.message);
      throw createError({ statusCode: 500, statusMessage: `Errore durante l'aggiornamento del dipendente: ${error.message}` });
    }

    if (!data) {
      // Questo caso si verifica se l'ID non corrisponde a nessun record
      throw createError({ statusCode: 404, statusMessage: 'Dipendente non trovato.' });
    }

    console.log('API Staff PUT: Dipendente aggiornato con successo:', data);
    return { status: 'success', message: 'Dipendente aggiornato con successo!', data: data };
  } catch (e) {
    console.error('Errore nel processare la richiesta PUT per staff:', e);
    throw createError({ statusCode: e.statusCode || 500, statusMessage: e.statusMessage || 'Errore interno del server.' });
  }
});


================================================
FILE: server/plugins/scheduler.js
================================================
// server/plugins/scheduler.js
import { Cron } from 'croner';
import { processNewIncomingEmails } from '../utils/mailProcessor';

export default defineNitroPlugin(async (nitroApp) => {
  // Aggiunto per debug: Controlla la variabile d'ambiente
  console.log('--- NITRO SERVER START ---');
  console.log('NODE_TLS_REJECT_UNAUTHORIZED (in Nitro):', process.env.NODE_TLS_REJECT_UNAUTHORIZED);
  console.log('--- END NITRO SERVER START ---');

  // Gestore globale per gli errori di Promise non catturati (unhandledRejection).
  process.on('unhandledRejection', (reason, promise) => {
    console.error('GLOBAL ERROR: Unhandled Rejection at Promise', promise, 'reason:', reason);
  });

  // Esegui la funzione di elaborazione email all'avvio del server Nitro.
  console.log('Initial email processing run on server start.');
  try {
    await processNewIncomingEmails();
  } catch (error) {
    console.error('Error during initial email processing run:', error);
  }

  // Programma l'esecuzione periodica della funzione di elaborazione email.
  console.log('Email processing scheduler started and scheduled to run every 5 minutes.');
  
  // *** MODIFICA QUI: Aggiungi "new" prima di Cron() e imposta a 5 minuti ***
  new Cron('*/5 * * * *', async () => { // Esegui ogni 5 minuti
    console.log('Running scheduled email processing (every 5 minutes)...');
    try {
      await processNewIncomingEmails();
    } catch (error) {
      console.error('Error during scheduled email processing run:', error);
    }
  }, { timezone: 'Europe/Rome' });


});


================================================
FILE: server/utils/aiService.js
================================================
// server/utils/aiService.js
import { useRuntimeConfig } from '#imports';
import { $fetch } from 'ofetch';
import { getSupabaseAdminClient } from './supabaseAdmin';

const config = useRuntimeConfig();
const GOOGLE_API_KEY = config.googleApiKey;
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GOOGLE_API_KEY}`;

// MODIFICA QUI: AGGIUNTO L'ISTRUZIONE PER client_name AL PROMPT
const PROMPT_EMAIL_TRIAGE = `
Sei un assistente AI super efficiente per uno studio di commercialisti. Il tuo compito ÃƒÂ¨ analizzare un'email in arrivo e assegnarla al membro dello staff piÃƒÂ¹ appropriato.

Inoltre, devi determinare se l'email ÃƒÂ¨ URGENTE. Un'email ÃƒÂ¨ urgente se contiene parole come "urgente",  "ora", "subito", "immediato", "critico", "deadline", "scadenza", o se il contesto implica una richiesta che richiede attenzione immediata.

Infine, devi estrarre le informazioni di contatto del mittente come nome completo, numero di telefono e comune, se presenti nel corpo dell'email.

Ecco la lista del personale e delle loro responsabilitÃƒÂ . Ogni membro ha un ID unico (UUID).
--- LISTA PERSONALE ---
{staff_list}
-----------------------

Analizza il seguente contenuto dell'email (mittente, oggetto e corpo) e determina:
1.Se nella mail trovi un commento html con dentro un tag span, prendi il contenuto del tag span e usalo come clientid. Se non lo trovi, procedi coi punti sotto, altrimenti restituisci l'oggetto JSON con clientid, telefono e comune che trovi analizzando il corpo della mail. Se trovi tutto, restituisci e metti nell'oggetto un indice 'followUpDone' settato a 1, altrimenti metti 'followUpDone' a 2 se manca qualche campo.
2. Quale persona dello staff ÃƒÂ¨ il piÃƒÂ¹ adatto a gestirla.
3. Se l'email ÃƒÂ¨ urgente.
4. Se il nome completo del mittente ÃƒÂ¨ presente.
5. Se il numero di telefono del mittente ÃƒÂ¨ presente.
6. Se il comune/cittÃƒÂ  del mittente ÃƒÂ¨ presente.

--- CONTENUTO EMAIL ---
Mittente: {email_from}
Oggetto: {email_subject}
Corpo: {email_body}
-----------------------

La tua risposta DEVE essere un oggetto JSON con il seguente formato, senza alcun testo aggiuntivo:
{
  "assigned_to_staff_id": "L'UUID ESATTO del dipendente scelto dalla LISTA PERSONALE sopra. Non inventare o alterare gli UUID. Se NESSUNO nella lista sembra appropriato o non sei sicuro, DEVI restituire null.",
  "ai_confidence_score": un numero da 0.0 (per niente sicuro) a 1.0 (molto sicuro),
  "ai_reasoning": "Una breve frase che spiega perchÃƒÂ© hai scelto quel dipendente/ufficio e se l'email ÃƒÂ¨ considerata urgente.",
  "is_urgent": true/false, // Indica se l'email ÃƒÂ¨ urgente in base al contenuto.
  "client_name": "Il nome completo del mittente estratto dal corpo dell'email, se presente. Restituisci null se non trovato.", // NUOVO
  "client_phone_number": "Il numero di telefono estratto dal corpo dell'email, se presente. Restituisci null se non trovato.",
  "client_city": "Il comune o la cittÃƒÂ  estratti dal corpo dell'email, se presenti. Restituisci null se non trovato."
}
`;
const PROMPT_INFOS_EXTRACTION =`
Sei un assistente AI e il tuo compito Ã¨ estrarre informazioni chiave da un'email.

--- CONTENUTO EMAIL ---
Mittente: {email_from}
Numero: {email_phone_number}
Comune: {email_city}
-----------------------

La tua risposta DEVE essere un oggetto JSON con il seguente formato, senza alcun testo aggiuntivo:
{
  "client_name": "Il nome completo del mittente estratto dal corpo dell'email, se presente. Restituisci null se non trovato.",
  "client_phone_number": "Il numero di telefono estratto dal corpo dell'email, se presente. Restituisci null se non trovato.",
  "client_city": "Il comune o la cittÃ  estratti dal corpo dell'email, se presenti. Restituisci null se non trovato."
}
`;

export async function analyzeEmailWithAI(sender, subject, body_text) {
    const supabaseAdmin = getSupabaseAdminClient();
    const { data: staff, error: staffError } = await supabaseAdmin.from('staff').select('id, name, text_skills, skills, email');
    if (staffError) {
        console.error('AI_SERVICE: Error fetching staff for AI:', staffError.message);
        throw new Error('Impossibile caricare il personale per l\'analisi AI.');
    }
    if (!staff || staff.length === 0) {
        console.warn('AI_SERVICE: Nessun personale configurato nel database per l\'analisi AI.');
        return {
            assigned_to_staff_id: null,
            ai_confidence_score: 0.1,
            ai_reasoning: "Nessun personale configurato per l'assegnazione.",
            assignedStaffEmail: null,
            assignedStaffName: null,
            is_urgent: false, 
            client_name: null, // NUOVO
            client_phone_number: null,
            client_city: null,
        };
    }

    const staffListForPrompt = staff.map(s => {
      const skillsDescription = s.skills && s.skills.length > 0
        ? `Competenze: ${s.skills.join(', ')}`
        : `Descrizione: ${s.text_skills}`;
      return `ID: ${s.id}, Nome: ${s.name}, ${skillsDescription}, Email: ${s.email}`;
    }).join('\n');

    const finalPrompt = PROMPT_EMAIL_TRIAGE
        .replace('{staff_list}', staffListForPrompt)
        .replace('{email_from}', sender)
        .replace('{email_subject}', subject)
        .replace('{email_body}', body_text ? body_text.substring(0, 4000) : 'No body text provided');

    let aiResponse;
    try {
        console.log('AI_SERVICE: Sending request to Gemini...');
        const response = await $fetch.raw(GEMINI_API_URL, {
            method: 'POST',
            body: { contents: [{ parts: [{ text: finalPrompt }] }] },
            headers: { 'Content-Type': 'application/json' },
        });
        const responseData = response._data;
        const rawResponseText = responseData.candidates?.[0]?.content?.parts?.[0]?.text;
console.log('AI_SERVICE: Gemini response received:', rawResponseText);
        if (!rawResponseText) {
            console.error('AI_SERVICE: Gemini did not return valid text content.');
            throw new Error('Risposta non valida o malformata da Gemini: contenuto testuale mancante.');
        }

        console.log('AI_SERVICE: Raw text response from Gemini (partial):', rawResponseText.substring(0, Math.min(rawResponseText.length, 500)) + '...');

        const jsonMatch = rawResponseText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
        let jsonString = '';
        if (jsonMatch && jsonMatch[1]) {
            jsonString = jsonMatch[1].trim();
            console.log('AI_SERVICE: JSON block extracted via regex.');
        } else {
            console.warn('AI_SERVICE: No markdown JSON block found. Attempting to parse entire response as JSON.');
            jsonString = rawResponseText.trim();
        }

        try {
            aiResponse = JSON.parse(jsonString);
            console.log('AI_SERVICE: Parsed AI response JSON:', JSON.stringify(aiResponse));
            // NUOVO LOG: Verifica i campi client_name, client_phone_number e client_city estratti da Gemini
            console.log(`AI_SERVICE: Extracted client data - Name: ${aiResponse.client_name}, Phone: ${aiResponse.client_phone_number}, City: ${aiResponse.client_city}`);
        } catch (parseError) {
            console.error('AI_SERVICE: Error parsing JSON from Gemini:', parseError);
            console.error('AI_SERVICE: Malformed JSON string received:', jsonString);
            throw new Error(`Risposta AI malformata: ${parseError.message}`);
        }

    } catch (e) {
        console.error("AI_SERVICE: Error calling Gemini API:", e.message);
        throw new Error(`Errore durante l'analisi AI dell'email: ${e.message}`);
    }

    const bestMatchStaff = staff.find(s => s.id === aiResponse.assigned_to_staff_id);
    const finalAssignedId = bestMatchStaff ? aiResponse.assigned_to_staff_id : null;

    const isUrgent = typeof aiResponse.is_urgent === 'boolean' ? aiResponse.is_urgent : false;
    // Pulisci e normalizza i valori estratti, impostandoli a null se vuoti o non validi
    const clientName = aiResponse.client_name && String(aiResponse.client_name).trim() !== '' ? String(aiResponse.client_name).trim() : null; // NUOVO
    const clientPhoneNumber = aiResponse.client_phone_number && String(aiResponse.client_phone_number).trim() !== '' ? String(aiResponse.client_phone_number).trim() : null;
    const clientCity = aiResponse.client_city && String(aiResponse.client_city).trim() !== '' ? String(aiResponse.client_city).trim() : null;
   


    console.log('AI_SERVICE: Final AI Result being returned:', {
        assigned_to_staff_id: finalAssignedId,
        ai_confidence_score: parseFloat(aiResponse.ai_confidence_score) || 0,
        ai_reasoning: aiResponse.ai_reasoning,
        assignedStaffEmail: bestMatchStaff?.email || null,
        assignedStaffName: bestMatchStaff?.name || null,
        is_urgent: isUrgent,
        client_name: clientName, // NUOVO
        client_phone_number: clientPhoneNumber,
        client_city: clientCity,
    });

    return {
        assigned_to_staff_id: finalAssignedId,
        ai_confidence_score: parseFloat(aiResponse.ai_confidence_score) || 0,
        ai_reasoning: aiResponse.ai_reasoning,
        assignedStaffEmail: bestMatchStaff?.email || null,
        assignedStaffName: bestMatchStaff?.name || null,
        is_urgent: isUrgent,
        client_name: clientName, // NUOVO
        client_phone_number: clientPhoneNumber,
        client_city: clientCity,
    };
}


================================================
FILE: server/utils/clientManager.js
================================================
// server/utils/clientManager.js
import { getSupabaseAdminClient } from './supabaseAdmin';

/**
 * Gestisce l'upsert (insert o update) di un record cliente.
 * Se un cliente con l'email esiste giÃƒ , lo aggiorna con i nuovi dati se piÃƒÂ¹ completi.
 * Resetta il flag 'follow_up_email_sent' se vengono aggiunti dati mancanti.
 *
 * @param {string} email L'email del cliente (obbligatoria).
 * @param {string|null} clientName Il nome del cliente estratto.
 * @param {string|null} phoneNumber Il numero di telefono estratto.
 * @param {string|null} city Il comune/cittÃƒÂ  estratto.
 * @param {string} emailId L'ID dell'email che ha triggerato l'upsert.
 * @param {string|null} followUpMessageId L'ID del messaggio della follow-up email appena inviata (opzionale).
 * @returns {Promise<object>} Il record cliente aggiornato o appena creato.
 */
export async function upsertClient(email, clientName, phoneNumber, city, emailId, followUpMessageId = null) {
    const supabaseAdmin = getSupabaseAdminClient();
    console.log(`CLIENT_MANAGER: Upserting client for email: ${email}`);
    console.log(`CLIENT_MANAGER: Input data - Name: ${clientName}, Phone: ${phoneNumber}, City: ${city}, Email ID: ${emailId}, FollowUpMsgID: ${followUpMessageId}`);
    try {
        const { data: existingClient, error: fetchError } = await supabaseAdmin
            .from('clients')
            .select('*')
            .eq('email', email)
            .single();

        if (fetchError && fetchError.code !== 'PGRST116') {
            console.error('CLIENT_MANAGER: Error fetching client:', fetchError.message);
            throw new Error(`Failed to fetch client: ${fetchError.message}`);
        }

        let clientDataToSave = {
            email: email,
            last_email_id: emailId,
        };

        if (existingClient) {
            console.log('CLIENT_MANAGER: Existing client found. Checking for updates.');
            console.log(`CLIENT_MANAGER: Existing client state - Name: ${existingClient.name}, Phone: ${existingClient.phone_number}, City: ${existingClient.city}, FollowUpSent: ${existingClient.follow_up_email_sent}, FollowUpMsgID: ${existingClient.follow_up_message_id}`);

            let updatedFields = {};
            let needsUpdate = false;
            let resetFollowUpFlag = false;

            if (clientName && (!existingClient.name || existingClient.name.trim() === '')) {
                updatedFields.name = clientName; needsUpdate = true;
                console.log('CLIENT_MANAGER: Updating name (was missing/empty).');
                if (existingClient.follow_up_email_sent) resetFollowUpFlag = true;
            } else if (clientName && existingClient.name !== clientName) {
                updatedFields.name = clientName; needsUpdate = true;
                console.log('CLIENT_MANAGER: Updating name (changed).');
            } else if (!clientName && existingClient.name) {
                updatedFields.name = existingClient.name;
            } else {
                updatedFields.name = null;
            }

            if (phoneNumber && (!existingClient.phone_number || existingClient.phone_number.trim() === '')) {
                updatedFields.phone_number = phoneNumber; needsUpdate = true;
                console.log('CLIENT_MANAGER: Updating phone number (was missing/empty).');
                if (existingClient.follow_up_email_sent) resetFollowUpFlag = true;
            } else if (phoneNumber && existingClient.phone_number !== phoneNumber) {
                updatedFields.phone_number = phoneNumber; needsUpdate = true;
                console.log('CLIENT_MANAGER: Updating phone number (changed).');
            } else if (!phoneNumber && existingClient.phone_number) {
                updatedFields.phone_number = existingClient.phone_number;
            } else {
                updatedFields.phone_number = null;
            }
            
            if (city && (!existingClient.city || existingClient.city.trim() === '')) {
                updatedFields.city = city; needsUpdate = true;
                console.log('CLIENT_MANAGER: Updating city (was missing/empty).');
                if (existingClient.follow_up_email_sent) resetFollowUpFlag = true;
            } else if (city && existingClient.city !== city) {
                updatedFields.city = city; needsUpdate = true;
                console.log('CLIENT_MANAGER: Updating city (changed).');
            } else if (!city && existingClient.city) {
                updatedFields.city = existingClient.city;
            } else {
                updatedFields.city = null;
            }

            updatedFields.last_email_id = emailId;
            needsUpdate = true;

            if (followUpMessageId !== null) {
                updatedFields.follow_up_message_id = followUpMessageId;
                needsUpdate = true;
            } else {
                const allInfoComplete = !(updatedFields.name === null || updatedFields.phone_number === null || updatedFields.city === null);
                if (resetFollowUpFlag || (existingClient.follow_up_email_sent && allInfoComplete)) {
                     updatedFields.follow_up_message_id = null;
                     needsUpdate = true;
                } else {
                    updatedFields.follow_up_message_id = existingClient.follow_up_message_id;
                }
            }


            const currentHasMissingInfo = (updatedFields.name === null || updatedFields.name.trim() === '') || 
                                          (updatedFields.phone_number === null || updatedFields.phone_number.trim() === '') || 
                                          (updatedFields.city === null || updatedFields.city.trim() === '');
            
            if (resetFollowUpFlag || (existingClient.follow_up_email_sent && !currentHasMissingInfo)) {
                console.log('CLIENT_MANAGER: Condition met to reset follow-up flag (was sent and info is now complete, or new info just added).');
                updatedFields.follow_up_email_sent = false;
                updatedFields.follow_up_sent_at = null;
                needsUpdate = true;
            } else {
                updatedFields.follow_up_email_sent = existingClient.follow_up_email_sent;
                updatedFields.follow_up_sent_at = existingClient.follow_up_sent_at;
            }
            
            console.log('CLIENT_MANAGER: Fields to update for existing client:', updatedFields);
            console.log('CLIENT_MANAGER: Needs update flag:', needsUpdate);

            if (needsUpdate) {
                const { data, error: updateError } = await supabaseAdmin
                    .from('clients')
                    .update(updatedFields)
                    .eq('id', existingClient.id)
                    .select()
                    .single();
                if (updateError) {
                    console.error('CLIENT_MANAGER: Error updating client:', updateError.message);
                    if (updateError.code === '42501') console.error("CLIENT_MANAGER: RLS Issue? Check 'clients' table policies in Supabase.");
                    throw new Error(`Failed to update client: ${updateError.message}`);
                }
                console.log('CLIENT_MANAGER: Client updated:', data);
                return data;
            } else {
                console.log('CLIENT_MANAGER: No significant updates needed for existing client. Returning existing data.');
                return existingClient;
            }

        } else {
            console.log('CLIENT_MANAGER: No existing client found. Inserting new client.');
            clientDataToSave.name = clientName;
            clientDataToSave.phone_number = phoneNumber;
            clientDataToSave.city = city;
            clientDataToSave.follow_up_email_sent = false;
            clientDataToSave.follow_up_message_id = followUpMessageId;

            console.log('CLIENT_MANAGER: Data for new client insert:', clientDataToSave);

            const { data, error: insertError } = await supabaseAdmin
                .from('clients')
                .insert([clientDataToSave])
                .select()
                .single();
            if (insertError) {
                console.error('CLIENT_MANAGER: Error inserting new client:', insertError.message);
                if (insertError.code === '23505') console.error('CLIENT_MANAGER: Unique constraint violation (e.g., email already exists).');
                if (insertError.code === '42501') console.error("CLIENT_MANAGER: RLS Issue? Check 'clients' table policies in Supabase.");
                throw new Error(`Failed to insert new client: ${insertError.message}`);
            }
            console.log('CLIENT_MANAGER: New client inserted:', data);
            return data;
        }

    } catch (e) {
        console.error('CLIENT_MANAGER: Unhandled error in upsertClient:', e);
        throw e;
    }
}

/**
 * Recupera un record cliente tramite email.
 * @param {string} email
 * @returns {Promise<object|null>} Il record cliente o null se non trovato.
 */
export async function getClient(email) {
    const supabaseAdmin = getSupabaseAdminClient();
    try {
        const { data, error } = await supabaseAdmin
            .from('clients')
            .select('*')
            .eq('email', email)
            .single();
        if (error && error.code !== 'PGRST116') {
            console.error('CLIENT_MANAGER: Error getting client:', error.message);
            throw new Error(`Failed to get client: ${error.message}`);
        }
        return data;
    } catch (e) {
        console.error('CLIENT_MANAGER: Unhandled error in getClient:', e);
        throw e;
    }
}
// QUESTA RIGA Ãˆ STATA MODIFICATA: AGGIUNTA LA KEYWORD 'export'
export async function getClientByFollowUpMessageId(messageId) {
    const supabaseAdmin = getSupabaseAdminClient();
    try {
        const { data, error } = await supabaseAdmin
            .from('clients')
            .select('*')
            .eq('follow_up_message_id', messageId)
            .single();
        if (error && error.code !== 'PGRST116') {
            console.error('CLIENT_MANAGER: Error getting client by follow_up_message_id:', error.message);
            throw new Error(`Failed to get client by follow_up_message_id: ${error.message}`);
        }
        return data;
    } catch (e) {
        console.error('CLIENT_MANAGER: Unhandled error in getClientByFollowUpMessageId:', e);
        throw e;
    }
}


================================================
FILE: server/utils/emailSender.js
================================================
// server/utils/emailSender.js
import sgMail from '@sendgrid/mail';
import { useRuntimeConfig } from '#imports';

const config = useRuntimeConfig();
sgMail.setApiKey(config.sendgridApiKey);

// AGGIUNTA DI UN NUOVO PARAMETRO 'attachments'
export async function sendEmail(to, fromName, fromAddress, subject, originalBody, aiReasoning, attachments =  []) {
  const SENDER_EMAIL = config.senderEmail; // L'email verificata in SendGrid (test@aitaky.it)

  const htmlBody = `
    <div style="font-family: sans-serif; border: 1px solid #ddd; padding: 16px; border-radius: 8px;">
      <p><strong>Questa email ÃƒÂ¨ stata smistata automaticamente dal sistema AI.</strong></p>
      <p style="background-color: #f5f5f5; padding: 12px; border-radius: 4px;">
        <strong>Motivazione AI:</strong> <em>${aiReasoning}</em>
      </p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 16px 0;">
      <h3>Email Originale</h3>
      <p><strong>Da:</strong> ${fromName} <${fromAddress}></p>
      <p><strong>Oggetto:</strong> ${subject}</p>
      <div style="border-left: 3px solid #ccc; padding-left: 1em; margin-top: 1em; color: #555;">
        <pre style="white-space: pre-wrap; font-family: inherit;">${originalBody}</pre>
      </div>
    </div>
  `;

  const msg = {
    to: to,
    from: SENDER_EMAIL, // Usa l'email configurata in .env e verificata in SendGrid
    subject: `[Smistato da AI] ${subject}`,
    html: htmlBody,
    replyTo: fromAddress, // Permette di rispondere direttamente al cliente originale
    attachments: attachments // PASSIAMO GLI ALLEGATI A SENDGRID QUI
  };

  try {
    await sgMail.send(msg);
    console.log(`Email inoltrata con successo a ${to} tramite SendGrid.`);
  } catch (error) {
    console.error("Errore durante l'inoltro con SendGrid:", error.response?.body || error.message);
    // Puoi anche loggare dettagli specifici se l'errore ÃƒÂ¨ un SendGridError (es. allegati troppo grandi)
    if (error.response && error.response.body && error.response.body.errors) {
        error.response.body.errors.forEach(e => console.error(`SendGrid Error Detail: ${e.message}`));
    }
    throw error; // Rilancia l'errore per gestirlo nel chiamante
  }
}

// NUOVA FUNZIONE PER L'EMAIL DI FOLLOW-UP
export async function sendFollowUpRequest(toEmail, clientName, missingInfoDescription , clientid, originalReference = null) {
    const SENDER_EMAIL = config.senderEmail; // L'email verificata in SendGrid

    const subject = `Richiesta Informazioni Aggiuntive - Studio Commercialista`;
    const htmlBody = `
  <div style="font-family: sans-serif; border: 1px solid #ddd; padding: 16px; border-radius: 8px;">
    <p>Gentile ${clientName || 'Cliente'},</p>
    <p>Abbiamo ricevuto la sua email e la stiamo processando.</p>
    <p>Per poterla assistere al meglio e completare la sua richiesta in modo efficiente, avremmo bisogno di alcune informazioni aggiuntive:</p>
    <p><strong>${missingInfoDescription}</strong></p>
    <p>La preghiamo di rispondere a questa email fornendoci le informazioni richieste.</p>
    <p>Grazie per la sua collaborazione.</p>
    <p>Cordiali saluti,<br/>Il team dello Studio Commercialista</p>
  </div>
`;

    const msg = {
        to: toEmail,
        from: SENDER_EMAIL,
        subject: subject,
        html: htmlBody,
        // Non impostiamo replyTo qui per evitare loop, ma il cliente puÃ² rispondere direttamente
    };
    if (originalReference) {
        const originalMessageId = originalReference;
        msg.headers = {
          'In-Reply-To': originalMessageId,
          'References': originalMessageId
        };
    }
    try {
        await sgMail.send(msg);
        console.log(`EMAIL_SENDER: Follow-up email sent successfully to ${toEmail}.`);
    } catch (error) {
        console.error("EMAIL_SENDER: Error sending follow-up email with SendGrid:", error.response?.body || error.message);
        if (error.response && error.response.body && error.response.body.errors) {
            error.response.body.errors.forEach(e => console.error(`SendGrid Error Detail: ${e.message}`));
        }
        throw error;
    }
}


================================================
FILE: server/utils/imapClient.js
================================================
// server/utils/imapClient.js
import Imap from 'node-imap';
import { simpleParser } from 'mailparser';

export async function fetchNewEmails(config) {
  console.log('IMAP Client Config for fetchNewEmails:', {
    user: config.imapUsername,
    host: config.imapHost,
    port: config.imapPort,
    tls: true,
    tlsOptsRejectUnauthorized: false // Esplicito per il log
  });

  const imap = new Imap({
    user: config.imapUsername,
    password: config.imapPassword,
    host: config.imapHost,
    port: config.imapPort,
    tls: true,
    tlsOpts: { rejectUnauthorized: false }
  });

  let connectionState = 'connecting';
  const endConnection = (error = null) => {
    if (connectionState === 'closed') {
      return;
    }
    try {
      if (imap.state !== 'disconnected') {
        imap.end();
      }
      connectionState = 'closed';
      if (error) {
        console.error('IMAP: Connection ended due to error, but trying to close gracefully:', error.message);
      } else {
        console.log('IMAP: Connection gracefully closed.');
      }
    } catch (e) {
      console.warn('IMAP: Error during imap.end() call (ignored, likely already closed):', e.message);
      connectionState = 'closed';
    }
  };

  return new Promise(async (resolve, reject) => {
    imap.once('ready', () => {
      connectionState = 'ready';
      console.log('IMAP: Connected successfully to the main client!');

      if (imap.client && imap.client.socket) {
        imap.client.socket.on('error', (err) => {
          if (err.code === 'ECONNRESET') {
            console.warn('IMAP (Socket): Received ECONNRESET. This is often a benign post-operation disconnect.', err.message);
          } else {
            console.error('IMAP (Socket): Unhandled socket error:', err);
          }
          endConnection(err);
        });
      } else {
          console.warn('IMAP: imap.client or imap.client.socket was not available after ready event. Socket error handling might be incomplete.');
      }

      imap.openBox(config.imapMailbox, false, (err, box) => {
        if (err) {
          console.error('IMAP: Error opening mailbox:', err);
          endConnection(err);
          return reject(err);
        }
        console.log(`IMAP: Mailbox "${config.imapMailbox}" opened.`);

        imap.search(['UNSEEN'], (err, uids) => {
          if (err) {
            console.error('IMAP: Error searching for emails:', err);
            endConnection(err);
            return reject(err);
          }

          if (!uids || uids.length === 0) {
            console.log('IMAP: No new unseen emails.');
            endConnection();
            return resolve([]);
          }

          console.log(`IMAP: Found ${uids.length} unseen emails. Fetching them.`);

          const fetchPromises = [];

          // Assicurati che 'bodies: '' sia sufficiente per gli allegati, lo Ã¨ per default con mailparser
          const f = imap.fetch(uids, { bodies: '' });

          f.on('message', (msg, seqno) => {
            let buffer = '';
            let currentUid;

            msg.once('attributes', (attrs) => {
              currentUid = attrs.uid;
            });

            const messagePromise = new Promise(messageResolve => {
              msg.on('body', (stream) => {
                stream.on('data', (chunk) => {
                  buffer += chunk.toString('utf8');
                });
                stream.once('end', async () => {
                  try {
                    const parsed = await simpleParser(buffer);
console.log('Parsing email with simpleParser:', parsed || 'No subject');
                    // --- NUOVI LOG PER DEBUG ALLEGATI ---
                    console.log(`IMAP: Message #${seqno} parsed. Attachments count: ${parsed.attachments ? parsed.attachments.length : 0}`);
                    if (parsed.attachments && parsed.attachments.length > 0) {
                        parsed.attachments.forEach((att, i) => {
                            console.log(`  Attachment ${i + 1}: Filename='${att.filename}', ContentType='${att.contentType}', Size=${att.size} bytes. Content (Buffer/Uint8Array) present: ${!!att.content && att.content.length > 0}`);
                        });
                    }
                    // --- FINE NUOVI LOG ---

                    messageResolve({
                      uid: currentUid,
                      messageId: parsed.messageId,
                      references: parsed.references ? (Array.isArray(parsed.references) ? parsed.references[0] ||  parsed.inReplyTo ||  parsed.messageID : parsed.references) : null,
                      from: parsed.from?.text,
                      to: parsed.to?.text,
                      subject: parsed.subject,
                      text: parsed.text,
                      html: parsed.html,
                      date: parsed.date,
                      raw: buffer,
                      attachments: parsed.attachments || [] // Questa riga Ã¨ corretta
                    });
                  } catch (parseErr) {
                    console.error('IMAP: Error parsing email:', parseErr);
                    messageResolve(null);
                  }
                });
              });
            });
            fetchPromises.push(messagePromise);
          });

          f.once('error', (fetchErr) => {
            console.error('IMAP: Fetch stream error:', fetchErr);
            endConnection(fetchErr);
            reject(fetchErr);
          });

          f.once('end', async () => {
            console.log('IMAP: Fetch stream ended. Waiting for all messages to parse.');
            const parsedEmails = (await Promise.all(fetchPromises)).filter(email => email !== null);
            console.log(`IMAP: Successfully parsed ${parsedEmails.length} emails.`);

            if (parsedEmails.length > 0) {
              const validUidsToMark = parsedEmails.map(e => e.uid).filter(uid => uid !== undefined && uid !== null);

              if (validUidsToMark.length > 0) {
                try {
                  await new Promise((flagResolve, flagReject) => {
                    imap.addFlags(validUidsToMark, ['\\Seen'], (flagErr) => {
                      if (flagErr) {
                        console.error('IMAP: Error marking emails as seen:', flagErr);
                        flagReject(flagErr);
                      } else {
                        console.log('IMAP: Valid emails marked as seen.');
                        flagResolve();
                      }
                    });
                  });
                } catch (addFlagsError) {
                  console.error('IMAP: Failed to mark emails as seen due to:', addFlagsError);
                }
                endConnection();
                resolve(parsedEmails);
              } else {
                console.warn('IMAP: No valid UIDs found to mark as seen, but emails were parsed. Ending connection.');
                endConnection();
                resolve(parsedEmails);
              }
            } else {
              console.log('IMAP: No emails parsed successfully. Ending connection.');
              endConnection();
              resolve([]);
            }
          });
        });
      });
    });

    imap.once('error', (err) => {
      if (['ECONNRESET', 'ETIMEDOUT', 'EPIPE'].includes(err.code) && connectionState === 'ready') {
        console.warn(`IMAP: Received a non-critical connection error (${err.code}). Ignoring as a potential post-operation issue.`, err.message);
      } else {
        console.error('IMAP: Global connection error:', err);
        reject(err);
      }
      endConnection(err);
    });

    imap.once('end', () => {
      console.log('IMAP: Connection gracefully ended (IMAP end event).');
    });

    imap.connect();
  });
}


================================================
FILE: server/utils/mailProcessor.js
================================================
// server/utils/mailProcessor.js
import { fetchNewEmails } from './imapClient';
import { analyzeEmailWithAI } from './aiService';
import { sendEmail, sendFollowUpRequest } from './emailSender';
import { getSupabaseAdminClient } from './supabaseAdmin';
import { upsertClient, getClientByFollowUpMessageId, getClient } from './clientManager'; // Aggiungi getClient per la ricerca per email

export async function processNewIncomingEmails() {
  console.log('MAIL_PROCESSOR: Starting email processing cycle...');
  const config = useRuntimeConfig();
  const supabaseAdmin = getSupabaseAdminClient();

  try {
    const incomingRawEmails = await fetchNewEmails(config);
    console.log(`MAIL_PROCESSOR: Fetched ${incomingRawEmails.length} new emails from IMAP.`);

    for (const email of incomingRawEmails) {
      console.log(`\n--- MAIL_PROCESSOR: Processing email from "${email.from}" - Subject: "${email.subject.substring(0, Math.min(email.subject.length, 50))}..." ---`);
      let emailRecordId = null;

      //console.log('EMAIL FULL', email);return
      try {
        // 0. Prepara il record email da verificare
        let references = email.references ? (Array.isArray(email.references) ? email.references[0] : email.references) : null;
        if(references){
            console.log('AAAAAA: References found:', references);
            const { data: fetchEm, error: errorFetchEm } = await supabaseAdmin.from('incoming_emails')
                    .select('*')
                    .eq('reference', references).maybeSingle();

            if(errorFetchEm) throw errorFetchEm;

            console.log('MAIL_PROCESSOR: Fetched email record for reference:', fetchEm);
        }else{

            // 1. Salva l'email raw nel database con stato 'new' INIZIALMENTE
            const { data: savedEmail, error: saveEmailError } = await supabaseAdmin.from('incoming_emails').insert([{
                sender: email.from,
                subject: email.subject,
                body_text: email.text,
                body_html: email.html,
                status: 'new', // Stato iniziale per tutte le email appena arrivate
                is_urgent: false,
                reference: email.messageId
            }]).select().single();

            if (saveEmailError) {
                console.error(`MAIL_PROCESSOR: ERROR saving new email to DB: ${saveEmailError.message}`);
                throw new Error(`Supabase save email error: ${saveEmailError.message}`);
            }
            emailRecordId = savedEmail.id;
            console.log(`MAIL_PROCESSOR: Email saved to DB with ID: ${emailRecordId}`);

            const originalMessageID = email.messageId;
            // --- NUOVO: Pre-processamento per risposte a email di follow-up (LOGICA AGGIORNATA) ---
            let isFollowUpReply = false;
            let repliedClient = null;
            let clientEmailFromHeader = email.from.match(/<(.+)>/)?.[1] || email.from; // Estrai l'email pura dal From header

            console.log(`MAIL_PROCESSOR: Checking for follow-up reply for sender email: ${clientEmailFromHeader}`);

            if (clientEmailFromHeader) {
                // Criterio Primario: Trova un client esistente con questo indirizzo email
                // e che abbia il flag follow_up_email_sent a TRUE.
                const potentialRepliedClient = await getClient(clientEmailFromHeader); // Usiamo getClient per trovare il record
                
                if (potentialRepliedClient && potentialRepliedClient.follow_up_email_sent === true) {
                    repliedClient = potentialRepliedClient;
                    isFollowUpReply = true;
                    console.log(`MAIL_PROCESSOR: Identified as a potential follow-up reply based on sender email and follow_up_email_sent flag for: ${repliedClient.email}`);

                    // Criterio Secondario (opzionale e non bloccante): Verifica gli header In-Reply-To/References
                    const headers = email.headers; // Parsed.headers from imapClient.js
                    if (headers && typeof headers.get === 'function' && repliedClient.follow_up_message_id) {
                        const inReplyToHeader = headers.get('in-reply-to');
                        const referencesHeader = headers.get('references');
                        let replyToId = null;

                        if (inReplyToHeader) {
                            const match = inReplyToHeader.match(/<([^>]+)>/);
                            if (match && match[1]) { replyToId = match[1]; }
                        } else if (referencesHeader) {
                            const ids = referencesHeader.match(/<([^>]+)>/g);
                            if (ids && ids.length > 0) { replyToId = ids[ids.length - 1].replace(/<|>/g, ''); }
                        }

                        console.log(`MAIL_PROCESSOR: Secondary check: Incoming Reply-To ID: ${replyToId}, Stored Follow-Up Message ID: ${repliedClient.follow_up_message_id}`);
                        if (replyToId && replyToId === repliedClient.follow_up_message_id) {
                            console.log(`MAIL_PROCESSOR: Secondary check CONFIRMED: Message IDs match.`);
                            // isFollowUpReply remains true
                        } else {
                            console.warn(`MAIL_PROCESSOR: Secondary check FAILED for ${repliedClient.email}: Message IDs do NOT match or replyToId is missing. Still processing as reply due to primary check.`);
                            // L'email sarÃ  comunque processata come risposta se il criterio primario Ã¨ vero.
                        }
                    } else {
                        console.log(`MAIL_PROCESSOR: Secondary check skipped for ${repliedClient.email} (headers missing/no get method, or no stored follow_up_message_id).`);
                    }
                }
            }

            // Se l'email Ã¨ una risposta a un follow-up (basato su primary/secondary check), la processiamo diversamente e saltiamo il resto del ciclo
            if (isFollowUpReply) {
                console.log(`MAIL_PROCESSOR: Handling follow-up reply for ${repliedClient.email}. Extracting info and updating client.`);
                // Analizza l'email per estrarre phone_number e city anche dalle risposte di follow-up
                const aiResultForReply = await analyzeEmailWithAI(email.from, email.subject, email.text || email.html);
                
                await upsertClient(
                    repliedClient.email,
                    aiResultForReply.client_name || repliedClient.name, // Preferisci AI, altrimenti nome esistente
                    aiResultForReply.client_phone_number,
                    aiResultForReply.client_city,
                    emailRecordId
                );

                await supabaseAdmin.from('incoming_emails').update({
                    status: 'processed_follow_up',
                    references: 'FA'+originalMessageID,
                    ai_reasoning: `Risposta a follow-up email. Dati cliente aggiornati.`
                }).eq('id', emailRecordId);

                console.log(`MAIL_PROCESSOR: Follow-up reply for ${repliedClient.email} processed and client data updated. Email status set to 'processed_follow_up'. Skipping AI triage and forwarding.`);
                continue; // Passa alla prossima email, saltando il resto del loop per questa email
            }
            // --- FINE NUOVO: Pre-processamento ---


            // --- GESTIONE ALLEGATI (Questo blocco e i successivi vengono eseguiti solo se la email NON era una risposta di follow-up) ---
            if (email.attachments && email.attachments.length > 0) {
            console.log(`MAIL_PROCESSOR: Found ${email.attachments.length} attachments for email ID ${emailRecordId}. Attempting upload and metadata save.`);
            for (const attachment of email.attachments) {
                console.log(`MAIL_PROCESSOR: Processing attachment: ${attachment.filename || 'N/A'}, Type: ${attachment.contentType || 'N/A'}, Size: ${attachment.size || 0} bytes.`);
                
                if (!attachment.content || !(attachment.content instanceof Buffer) || attachment.content.length === 0) {
                    console.warn(`MAIL_PROCESSOR: Attachment "${attachment.filename || 'N/A'}" has no valid content (or is empty). Skipping upload for this attachment.`);
                    continue;
                }

                try {
                const uniqueFileIdentifier = `${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                const storagePath = `${emailRecordId}/${uniqueFileIdentifier}_${attachment.filename}`;

                console.log(`MAIL_PROCESSOR: Attempting to upload "${attachment.filename}" to Storage at path: "email-attachments/${storagePath}"`);
                const { data: uploadData, error: uploadError } = await supabaseAdmin.storage
                    .from('email-attachments')
                    .upload(storagePath, attachment.content, {
                    contentType: attachment.contentType,
                    upsert: true
                    });

                if (uploadError) {
                    console.error(`MAIL_PROCESSOR: ERROR uploading attachment "${attachment.filename}" for email ID ${emailRecordId}:`, uploadError.message);
                    continue;
                }

                const publicUrlResult = supabaseAdmin.storage
                                    .from('email-attachments')
                                    .getPublicUrl(uploadData.path);

                const publicUrl = publicUrlResult.data?.publicUrl;
                if (!publicUrl) {
                    console.error(`MAIL_PROCESSOR: ERROR getting public URL for "${attachment.filename}":`, publicUrlResult.error?.message || 'Unknown error getting public URL.');
                    continue;
                }
                console.log(`MAIL_PROCESSOR: Attachment "${attachment.filename}" uploaded successfully. Public URL: ${publicUrl}`);

                const attachmentMetadataToSave = {
                    email_id: emailRecordId,
                    filename: attachment.filename || 'no-filename',
                    mimetype: attachment.contentType || 'application/octet-stream',
                    size: attachment.size || 0,
                    storage_path: storagePath,
                    public_url: publicUrl
                };

                console.log('MAIL_PROCESSOR: Data for email-attachments insert:', JSON.stringify(attachmentMetadataToSave, null, 2));

                console.log(`MAIL_PROCESSOR: Attempting to save attachment metadata for "${attachment.filename}" (email ID ${emailRecordId}).`);
                const { error: saveAttachError } = await supabaseAdmin.from('email-attachments').insert(attachmentMetadataToSave);

                if (saveAttachError) {
                    console.error(`MAIL_PROCESSOR: ERROR saving attachment metadata for "${attachment.filename}" (email ID ${emailRecordId}):`, saveAttachError.message || saveAttachError);
                } else {
                    console.log(`MAIL_PROCESSOR: Attachment metadata for "${attachment.filename}" saved to DB successfully.`);
                }

                } catch (uploadInnerError) {
                console.error(`MAIL_PROCESSOR: Unhandled error during attachment upload/save for "${attachment.filename || 'N/A'}" (email ID ${emailRecordId}):`, uploadInnerError.message || uploadInnerError);
                }
            }
            } else {
                console.log(`MAIL_PROCESSOR: No attachments found for email ID ${emailRecordId}.`);
            }
            // --- FINE GESTIONE ALLEGATI ---


            // 2. Analisi AI (per email NON riconosciute come risposte follow-up)
            console.log(`MAIL_PROCESSOR: Initiating AI analysis for email ID ${emailRecordId}...`);
            const aiResult = await analyzeEmailWithAI(email.from, email.subject, email.text || email.html);
            console.log(`MAIL_PROCESSOR: AI analysis complete for email ID ${emailRecordId}. Result: `, aiResult);

            // Gestione del cliente (per email NON risposte a follow-up)
            let clientEmail = email.from.match(/<(.+)>/)?.[1] || email.from; 
            // Estraiamo il nome dal campo 'From' dell'email, se non estratto dall'AI
            const emailFromName = email.from.replace(/<.+>/, '').trim() || null;

            if (clientEmail) {
                try {
                    console.log(`MAIL_PROCESSOR: Attempting to upsert client data for email: ${clientEmail}`);
                    // Passa clientName a upsertClient
                    const updatedClient = await upsertClient(
                        clientEmail, 
                        aiResult.client_name || emailFromName, // Preferisci AI, altrimenti fromName
                        aiResult.client_phone_number, 
                        aiResult.client_city, 
                        emailRecordId
                    ); 
                    console.log(`MAIL_PROCESSOR: Client data upserted. Current client state:`, updatedClient);

                    // Logica di follow-up email
                    if (updatedClient) {
                        // La condizione ora include il nome
                        const hasMissingInfo = (updatedClient.name === null || updatedClient.name.trim() === '') || 
                                            (updatedClient.phone_number === null || updatedClient.phone_number.trim() === '') || 
                                            (updatedClient.city === null || updatedClient.city.trim() === '');
                        console.log(`MAIL_PROCESSOR: Follow-up check - Has missing info: ${hasMissingInfo}, Follow-up already sent: ${updatedClient.follow_up_email_sent}`);

                        if (hasMissingInfo && !updatedClient.follow_up_email_sent) {
                            let missingFields = [];
                            if (!updatedClient.name || updatedClient.name.trim() === '') missingFields.push("il suo nome completo");
                            if (!updatedClient.phone_number || updatedClient.phone_number.trim() === '') missingFields.push("il suo numero di telefono");
                            if (!updatedClient.city || updatedClient.city.trim() === '') missingFields.push("il suo comune/cittÃƒÂ  di residenza");
                            
                            const missingInfoDescription = `Ci mancano ${missingFields.join(' e ')}.`;

                            try {
                                console.log(`MAIL_PROCESSOR: Sending follow-up email to ${clientEmail} for missing info.`);
                                const clientNameForFollowUp = updatedClient.name || 'Cliente'; // Usa il nome dal DB o 'Cliente'
                                const clientidForFollowUp = updatedClient.id; // Usa l'ID del client per il follow-up
                                const followUpMessageId = await sendFollowUpRequest(clientEmail, clientNameForFollowUp, missingInfoDescription, clientidForFollowUp, originalMessageID);

                                await supabaseAdmin.from('clients').update({
                                    follow_up_email_sent: true,
                                    follow_up_sent_at: new Date().toISOString(),
                                    follow_up_message_id: followUpMessageId // Salva l'ID del messaggio della follow-up
                                }).eq('id', updatedClient.id);
                                console.log(`MAIL_PROCESSOR: Follow-up email sent and client flag updated for ${clientEmail}. Saved Message-ID: ${followUpMessageId}`);

                            } catch (followUpError) {
                                console.error(`MAIL_PROCESSOR: Error sending follow-up email to ${clientEmail}:`, followUpError);
                            }
                        } else {
                            console.log(`MAIL_PROCESSOR: No follow-up needed for client ${clientEmail} based on conditions.`);
                        }
                    }
                } catch (clientError) {
                    console.error(`MAIL_PROCESSOR: Error processing client data for ${clientEmail}:`, clientError);
                }
            }
            // FINE GESTIONE CLIENTE


            // 3. Aggiorna l'email nel DB con i risultati dell'AI (per email NON risposte a follow-up)
            const newStatus = aiResult.assigned_to_staff_id ? 'analyzed' : 'manual_review';
            
            console.log(`MAIL_PROCESSOR: Updating email ID ${emailRecordId} in DB with AI results. New status: ${newStatus}, Is Urgent: ${aiResult.is_urgent}`);
            const { error: updateAIError } = await supabaseAdmin.from('incoming_emails').update({
                assigned_to_staff_id: aiResult.assigned_to_staff_id,
                ai_confidence_score: aiResult.ai_confidence_score,
                ai_reasoning: aiResult.ai_reasoning,
                status: newStatus,
                is_urgent: aiResult.is_urgent,
            }).eq('id', emailRecordId);

            if (updateAIError) {
                console.error(`MAIL_PROCESSOR: ERROR updating email ID ${emailRecordId} with AI results: ${updateAIError.message}`);
                throw new Error(`Supabase AI update error: ${updateAIError.message}`);
            }
            console.log(`MAIL_PROCESSOR: AI analysis results successfully updated for email ID ${emailRecordId}.`);

            // 4. Inoltra l'email al destinatario suggerito dall'AI, se presente (per email NON risposte a follow-up)
            if (aiResult.assigned_to_staff_id && aiResult.assignedStaffEmail) {
                console.log(`MAIL_PROCESSOR: Attempting to forward email ID ${emailRecordId} to ${aiResult.assignedStaffEmail} (Assigned to: ${aiResult.assignedStaffName})...`);
                try {
                    const { data: attachmentsToForward, error: fetchAttachError } = await supabaseAdmin
                        .from('email-attachments')
                        .select('filename, mimetype, storage_path')
                        .eq('email_id', emailRecordId);

                    let sendgridAttachments = [];
                    if (fetchAttachError) {
                        console.error(`MAIL_PROCESSOR: ERROR fetching attachments for forwarding (email ID ${emailRecordId}):`, fetchAttachError.message);
                    } else if (attachmentsToForward && attachmentsToForward.length > 0) {
                        console.log(`MAIL_PROCESSOR: Found ${attachmentsToForward.length} attachments to prepare for forwarding.`);
                        for (const attachMeta of attachmentsToForward) {
                            try {
                                const { data: downloadedBlob, error: downloadError } = await supabaseAdmin.storage
                                    .from('email-attachments')
                                    .download(attachMeta.storage_path);

                                if (downloadError) {
                                    console.error(`MAIL_PROCESSOR: ERROR downloading attachment "${attachMeta.filename}" for forwarding:`, downloadError.message);
                                    continue;
                                }

                                if (!(downloadedBlob instanceof Blob)) {
                                    console.error(`MAIL_PROCESSOR: Expected Blob, received different type for "${attachMeta.filename}". Skipping attachment preparation.`);
                                    continue;
                                }

                                const arrayBuffer = await downloadedBlob.arrayBuffer();
                                const bufferContent = Buffer.from(arrayBuffer);
                                const contentBase64 = bufferContent.toString('base64');
                                
                                sendgridAttachments.push({
                                    content: contentBase64,
                                    filename: attachMeta.filename,
                                    type: attachMeta.mimetype,
                                    disposition: 'attachment',
                                });
                                console.log(`MAIL_PROCESSOR: Attachment "${attachMeta.filename}" prepared for SendGrid.`);

                            } catch (downloadOrEncodeError) {
                                console.error(`MAIL_PROCESSOR: ERROR preparing attachment "${attachMeta.filename}" for SendGrid:`, downloadOrEncodeError.message || downloadOrEncodeError);
                            }
                        }
                    }
                    
                    await sendEmail(
                        aiResult.assignedStaffEmail,
                        email.from.split('<')[0].trim() || email.from,
                        email.from,
                        email.subject,
                        email.text || email.html,
                        aiResult.ai_reasoning,
                        sendgridAttachments
                    );

                    await supabaseAdmin.from('incoming_emails').update({
                        status: 'forwarded',
                    }).eq('id', emailRecordId);
                    console.log(`MAIL_PROCESSOR: Email ID ${emailRecordId} successfully forwarded to ${aiResult.assignedStaffEmail} and status updated to 'forwarded'.`);

                } catch (forwardError) {
                    console.error(`MAIL_PROCESSOR: ERROR forwarding email ID ${emailRecordId}:`, forwardError);
                    await supabaseAdmin.from('incoming_emails').update({
                        status: 'forward_error',
                    }).eq('id', emailRecordId);
                    console.log(`MAIL_PROCESSOR: Status for email ID ${emailRecordId} updated to 'forward_error'.`);
                }
            } else {
                console.warn(`MAIL_PROCESSOR: Email ID ${emailRecordId} not assigned by AI or missing staff email. No forwarding attempted. Status remains '${newStatus}'.`);
            }
        }   
      } catch (innerError) {
        console.error(`MAIL_PROCESSOR: Critical ERROR processing single email (ID ${emailRecordId || 'N/A'}):`, innerError.message);
        if (emailRecordId) {
            console.log(`MAIL_PROCESSOR: Attempting to update email ID ${emailRecordId} status to 'processing_error'.`);
            await supabaseAdmin.from('incoming_emails').update({
                status: 'processing_error',
            }).eq('id', emailRecordId);
            console.log(`MAIL_PROCESSOR: Status for email ID ${emailRecordId} updated to 'processing_error'.`);
        }
      }
    }
  } catch (globalError) {
    console.error('MAIL_PROCESSOR: Global ERROR during email processing cycle:', globalError);
  }
  console.log('MAIL_PROCESSOR: Email processing cycle finished.');
}



================================================
FILE: server/utils/skillExtractor.js
================================================
// server/utils/skillExtractor.js
import { useRuntimeConfig } from '#imports';
import { $fetch } from 'ofetch';

const config = useRuntimeConfig();
const GOOGLE_API_KEY = config.googleApiKey;
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GOOGLE_API_KEY}`;

const PROMPT_SKILL_EXTRACTION = `
Sei un assistente AI specializzato nell'estrazione di competenze da una descrizione testuale.
Data la seguente descrizione di un dipendente/ufficio, estrai le singole competenze e restituiscile come un array JSON di stringhe.
Non includere nessun altro testo oltre all'array JSON.

Esempio di input: "Gestisce la contabilitÃƒÂ  generale, la fatturazione, e si occupa delle dichiarazioni fiscali. Conosce bene Excel e SAP."
Esempio di output: ["contabilitÃƒÂ  generale", "fatturazione", "dichiarazioni fiscali", "Excel", "SAP"]

Testo da analizzare:
"""
{text_skills_description}
"""
`;

export async function extractSkillsFromText(text_skills_description) {
  console.log("SKILL_EXTRACTOR: Inizio estrazione skills per:", text_skills_description ? text_skills_description.substring(0, Math.min(text_skills_description.length, 50)) + '...' : 'testo vuoto');

  if (!text_skills_description || text_skills_description.trim() === '') {
    console.warn("SKILL_EXTRACTOR: Testo competenze vuoto. Ritorno array vuoto.");
    return [];
  }

  const finalPrompt = PROMPT_SKILL_EXTRACTION.replace('{text_skills_description}', text_skills_description.trim());
  console.log("SKILL_EXTRACTOR: Prompt finale per Gemini (parziale):", finalPrompt.substring(0, Math.min(finalPrompt.length, 200)) + '...');

  try {
    const response = await $fetch.raw(GEMINI_API_URL, {
      method: 'POST',
      body: { contents: [{ parts: [{ text: finalPrompt }] }] },
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    const responseData = response._data;
    const rawResponseText = responseData.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!rawResponseText) {
      console.warn("SKILL_EXTRACTOR: Gemini non ha restituito contenuto testuale valido nel campo atteso.");
      return [];
    }
    
    console.log("SKILL_EXTRACTOR: Risposta testuale raw da Gemini (parziale):", rawResponseText.substring(0, Math.min(rawResponseText.length, 500)) + '...');

    // MIGLIORAMENTO CHIAVE: Tentativo di estrazione del blocco JSON usando regex piÃƒÂ¹ robusta
    const jsonMatch = rawResponseText.match(/```(?:json)?\s*([\s\S]*?)\s*```/); // Cattura anche senza 'json' dopo i backticks
    let jsonString = '';
    if (jsonMatch && jsonMatch[1]) {
        jsonString = jsonMatch[1].trim();
        console.log("SKILL_EXTRACTOR: Blocco JSON markdown trovato e estratto.");
    } else {
        // Fallback: se non trova il blocco ```...```, prova a parsare l'intera risposta
        console.warn("SKILL_EXTRACTOR: Blocco JSON markdown non trovato. Tentativo di parsing dell'intera risposta come JSON.");
        jsonString = rawResponseText.trim();
    }

    console.log("SKILL_EXTRACTOR: JSON grezzo (probabile) estratto per parsing:", jsonString.substring(0, Math.min(jsonString.length, 200)) + '...');

    let skillsArray = [];
    try {
        skillsArray = JSON.parse(jsonString);
    } catch (parseError) {
        console.error("SKILL_EXTRACTOR: Errore nel parsing JSON:", parseError);
        console.error("SKILL_EXTRACTOR: Stringa JSON malformata ricevuta:", jsonString);
        return []; // Restituisce array vuoto in caso di JSON invalido
    }

    if (!Array.isArray(skillsArray)) {
        console.warn("SKILL_EXTRACTOR: L'AI ha restituito un non-array per le skills dopo il parsing. Ritorno array vuoto.");
        return [];
    }

    const cleanedSkills = skillsArray.map(skill => String(skill).trim()).filter(skill => skill.length > 0);
    console.log("SKILL_EXTRACTOR: Skills estratte e pulite (Final):", cleanedSkills);
    return cleanedSkills;

  } catch (e) {
    console.error("SKILL_EXTRACTOR: Errore durante la chiamata Gemini per l'estrazione delle skills:", e);
    // In caso di errore AI/rete, restituisci un array vuoto per non bloccare l'operazione
    return []; 
  }
}


================================================
FILE: server/utils/supabaseAdmin.js
================================================
// server/utils/supabaseAdmin.js
import { createClient } from '@supabase/supabase-js';
import { useRuntimeConfig } from '#imports';

let supabaseAdminClient;

export function getSupabaseAdminClient() {
  if (!supabaseAdminClient) {
    const config = useRuntimeConfig();
    if (!config.public.supabaseUrl || !config.supabaseServiceRoleKey) {
      throw new Error('Missing Supabase URL or Service Role Key in runtimeConfig for admin client.');
    }
    // Usa la SERVICE_ROLE_KEY per operazioni lato server con piÃ¹ permessi
    supabaseAdminClient = createClient(config.public.supabaseUrl, config.supabaseServiceRoleKey, {
      auth: {
        persistSession: false, // Non persistere la sessione per un client server-side
      },
    });
  }
  return supabaseAdminClient;
}

