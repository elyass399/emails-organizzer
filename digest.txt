Directory structure:
└── emails-organizzer/
    ├── README.md
    ├── app.vue
    ├── components.json
    ├── nuxt.config.ts
    ├── package.json
    ├── tailwind.config.ts
    ├── test-imap-connection.js
    ├── tsconfig.json
    ├── assets/
    │   └── css/
    │       └── main.css
    ├── components/
    │   └── ui/
    │       ├── badge/
    │       │   ├── Badge.vue
    │       │   └── index.ts
    │       ├── button/
    │       │   ├── button.vue
    │       │   └── index.ts
    │       ├── card/
    │       │   ├── Card.vue
    │       │   ├── CardContent.vue
    │       │   ├── CardDescription.vue
    │       │   ├── CardFooter.vue
    │       │   ├── CardHeader.vue
    │       │   ├── CardTitle.vue
    │       │   └── index.ts
    │       ├── dialog/
    │       │   ├── Dialog.vue
    │       │   ├── DialogClose.vue
    │       │   ├── DialogContent.vue
    │       │   ├── DialogDescription.vue
    │       │   ├── DialogFooter.vue
    │       │   ├── DialogHeader.vue
    │       │   ├── DialogScrollContent.vue
    │       │   ├── DialogTitle.vue
    │       │   ├── DialogTrigger.vue
    │       │   └── index.ts
    │       ├── input/
    │       │   ├── index.ts
    │       │   └── Input.vue
    │       ├── label/
    │       │   ├── index.ts
    │       │   └── Label.vue
    │       ├── table/
    │       │   ├── index.ts
    │       │   ├── Table.vue
    │       │   ├── TableBody.vue
    │       │   ├── TableCaption.vue
    │       │   ├── TableCell.vue
    │       │   ├── TableEmpty.vue
    │       │   ├── TableFooter.vue
    │       │   ├── TableHead.vue
    │       │   ├── TableHeader.vue
    │       │   └── TableRow.vue
    │       ├── textarea/
    │       │   ├── index.ts
    │       │   └── Textarea.vue
    │       └── toast/
    │           ├── index.ts
    │           ├── Toast.vue
    │           ├── ToastAction.vue
    │           ├── ToastClose.vue
    │           ├── ToastDescription.vue
    │           ├── Toaster.vue
    │           ├── ToastProvider.vue
    │           ├── ToastTitle.vue
    │           ├── ToastViewport.vue
    │           └── use-toast.ts
    ├── lib/
    │   └── utils.ts
    ├── pages/
    │   └── index.vue
    ├── public/
    │   └── robots.txt
    └── server/
        ├── tsconfig.json
        ├── api/
        │   ├── inbox.get.js
        │   ├── staff.get.js
        │   ├── staff.post.js
        │   └── emails/
        │       ├── process.post.js
        │       └── webhook.post.js
        ├── plugins/
        │   └── scheduler.js
        └── utils/
            ├── aiService.js
            ├── emailSender.js
            ├── imapClient.js
            ├── mailProcessor.js
            └── supabaseAdmin.js

================================================
FILE: README.md
================================================
# Nuxt Minimal Starter

Look at the [Nuxt documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.



================================================
FILE: app.vue
================================================
<!-- File: app.vue -->
<template>
  <div>
    <!-- Questo componente Ã¨ utile per l'accessibilitÃ , annuncia i cambi di pagina agli screen reader -->
    <NuxtRouteAnnouncer />
    
    <!-- Questo Ã¨ il componente piÃ¹ importante.
         Nuxt renderizzerÃ  qui il contenuto della pagina corrente (es. pages/index.vue) -->
    <NuxtPage />
  </div>
</template>

<style>
/* Aggiungiamo uno stile di base per lo sfondo, cosÃ¬ l'app non Ã¨ completamente bianca */
body {
  background-color: #f8f9fa; /* Un grigio molto chiaro */
  color: #212529; /* Un nero morbido */
}

/* Stili per il tema scuro (opzionale, ma buona pratica) */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #f9f6f6; /* Un grigio scuro */
    color: #060000; /* Un bianco sporco */
  }
}
</style>


================================================
FILE: components.json
================================================
{
  "$schema": "https://shadcn-vue.com/schema.json",
  "style": "default",
  "tailwind": { "config": "tailwind.config.ts", "css": "assets/css/main.css", "baseColor": "slate", "cssVariables": true },
  "framework": "nuxt",
  "aliases": { "components": "@/components", "utils": "@/lib/utils" }
}


================================================
FILE: nuxt.config.ts
================================================
// File: nuxt.config.ts

export default defineNuxtConfig({
  devtools: { enabled: true },
  
  modules: [
    '@nuxtjs/tailwindcss',
    '@nuxtjs/supabase',
    'shadcn-nuxt'
  ],

  supabase: {
    url: process.env.SUPABASE_URL,
    key: process.env.NUXT_PUBLIC_SUPABASE_KEY,
    redirect: false,
  },

  shadcn: {
    prefix: '',
    componentDir: './components/ui'
  },

  runtimeConfig: {
    googleApiKey: process.env.GOOGLE_API_KEY,
    supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,
    sendgridApiKey: process.env.SENDGRID_API_KEY, 
    senderEmail: process.env.SENDER_EMAIL,
    imapHost: process.env.IMAP_HOST,
    imapPort: parseInt(process.env.IMAP_PORT || '993'),
    imapUsername: process.env.IMAP_USERNAME,
    imapPassword: process.env.IMAP_PASSWORD,
    imapMailbox: process.env.IMAP_MAILBOX || 'INBOX',
    public: {
      supabaseUrl: process.env.SUPABASE_URL,
      supabaseAnonKey: process.env.NUXT_PUBLIC_SUPABASE_KEY,
    }
  },


})


================================================
FILE: package.json
================================================
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "NODE_TLS_REJECT_UNAUTHORIZED=0 nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@sendgrid/mail": "^8.1.5",
    "@vueuse/core": "^13.5.0",
    "autoprefixer": "^10.4.21",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^17.2.0",
    "lucide-vue-next": "^0.525.0",
    "mailparser": "^3.7.4",
    "node-cron": "^4.2.0",
    "node-imap": "^0.9.6",
    "nuxt": "^3.17.6",
    "radix-vue": "^1.9.17",
    "reka-ui": "^2.3.2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.11",
    "vue": "^3.5.17",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@nuxtjs/supabase": "^1.5.3",
    "@nuxtjs/tailwindcss": "^7.0.0-beta.0",
    "@tailwindcss/nesting": "^0.0.0-insiders.565cd3e",
    "postcss": "^8.5.6",
    "shadcn-nuxt": "^2.2.0"
  }
}



================================================
FILE: tailwind.config.ts
================================================
// tailwind.config.ts
import type { Config } from 'tailwindcss'
import animate from 'tailwindcss-animate'

export default {
  darkMode: ['class'],
  safelist: ['dark'],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        // --- MODIFICHE QUI ---
        // Forziamo background e foreground per i componenti Shadcn che usano --background
        background: 'hsl(var(--background))', // Questa Ã¨ la definizione standard
        foreground: 'hsl(var(--foreground))', // Questa Ã¨ la definizione standard


        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      borderRadius: {
        xl: 'calc(var(--radius) + 4px)',
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'collapsible-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-collapsible-content-height)' },
        },
        'collapsible-up': {
          from: { height: 'var(--radix-collapsible-content-height)' },
          to: { height: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'collapsible-down': 'collapsible-down 0.2s ease-in-out',
        'collapsible-up': 'collapsible-up 0.2s ease-in-out',
      },
    },
  },
  plugins: [animate],
} satisfies Config


================================================
FILE: test-imap-connection.js
================================================
// test-imap-connection.js - Moduli ES Syntax

import 'dotenv/config'; // Importa dotenv in modo che carichi le variabili

import Imap from 'node-imap';
import { simpleParser } from 'mailparser';

const config = {
  imapHost: process.env.IMAP_HOST,
  imapPort: parseInt(process.env.IMAP_PORT || '993'),
  imapUsername: process.env.IMAP_USERNAME,
  imapPassword: process.env.IMAP_PASSWORD,
  imapMailbox: process.env.IMAP_MAILBOX || 'INBOX',
};

console.log('--- IMAP Test Connection ---');
console.log('IMAP_HOST:', config.imapHost);
console.log('IMAP_PORT:', config.imapPort);
console.log('IMAP_USERNAME:', config.imapUsername);
// Non loggare la password per sicurezza

// Attiva il debug verboso di node-imap (puÃ² essere molto dettagliato)
Imap.debug = console.log;

const imap = new Imap({
  user: config.imapUsername,
  password: config.imapPassword,
  host: config.imapHost,
  port: config.imapPort,
  tls: true,
  // *** IMPORTANTE: SOLO PER AMBIENTI DI SVILUPPO/TEST! ***
  // Questa opzione disabilita la verifica che il nome host del server IMAP
  // corrisponda al nome nel suo certificato SSL.
  // Ãˆ NECESSARIO se il tuo provider (es. Shellrent) usa un certificato generico.
  // Espone a vulnerabilitÃ  MITM in produzione. RIMUOVILA se vai in produzione con un certificato valido!
  tlsOpts: { rejectUnauthorized: false }
});

imap.once('ready', () => {
  console.log('IMAP: Connected successfully!');
  imap.openBox(config.imapMailbox, false, (err, box) => {
    if (err) {
      console.error('IMAP: Error opening mailbox:', err);
      imap.end();
      return;
    }
    console.log(`IMAP: Mailbox "${config.imapMailbox}" opened.`);

    // Cerca email non lette (UNSEEN)
    imap.search(['UNSEEN'], (err, uids) => {
      if (err) {
        console.error('IMAP: Error searching for emails:', err);
        imap.end();
        return;
      }

      if (!uids || uids.length === 0) {
        console.log('IMAP: No new unseen emails.');
        imap.end();
        return;
      }

      console.log(`IMAP: Found ${uids.length} unseen emails. Fetching them.`);

      const f = imap.fetch(uids, { bodies: '' }); // Fetch the entire email body
      f.on('message', (msg, seqno) => {
        console.log(`IMAP: Processing message #${seqno} (UID: ${uids[seqno - 1]})`);
        let buffer = '';
        msg.on('body', (stream) => {
          stream.on('data', (chunk) => {
            buffer += chunk.toString('utf8');
          });
          stream.once('end', async () => {
            try {
              const parsed = await simpleParser(buffer);
              console.log(`  From: ${parsed.from?.text}`);
              console.log(`  Subject: ${parsed.subject}`);
              console.log(`  Date: ${parsed.date}`);
              // Puoi aggiungere parsed.text o parsed.html per vedere il corpo
            } catch (parseErr) {
              console.error('  Error parsing email:', parseErr);
            }
          });
        });
      });

      f.once('error', (fetchErr) => {
        console.error('IMAP: Fetch error:', fetchErr);
        imap.end();
      });

      f.once('end', () => {
        console.log('IMAP: Finished fetching messages.');
        // Marca le email come lette, cosÃ¬ non le rileggi sempre
        imap.addFlags(uids, ['\\Seen'], (flagErr) => {
          if (flagErr) console.error('IMAP: Error marking emails as seen:', flagErr);
          console.log('IMAP: Emails marked as seen.');
          imap.end(); // Disconnettiti dall'IMAP
        });
      });
    });
  });
});

imap.once('error', (err) => {
  console.error('IMAP: Global error event:', err);
  imap.end();
});

imap.once('end', () => {
  console.log('IMAP: Connection gracefully closed.');
});

imap.connect();


================================================
FILE: tsconfig.json
================================================
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json"
}



================================================
FILE: assets/css/main.css
================================================
/* assets/css/main.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Aggiungi questa sezione per forzare lo sfondo bianco del DialogContent */
/* Questo sovrascrive lo stile di default di Shadcn per il DialogContent */
.dialog-content-force-white {
  background-color: white !important;
  color: black !important;
}

/* Forse necessario anche per il tema scuro, se dark mode Ã¨ attivo */
.dark .dialog-content-force-white {
  background-color: white !important;
  color: black !important;
}


================================================
FILE: components/ui/badge/Badge.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { type BadgeVariants, badgeVariants } from '.'
import { cn } from '@/lib/utils'
interface Props { variant?: BadgeVariants['variant']; class?: HTMLAttributes['class'] }
const props = defineProps<Props>()
</script>
<template><div :class="cn(badgeVariants({ variant }), props.class)"><slot /></div></template>


================================================
FILE: components/ui/badge/index.ts
================================================
import { type VariantProps, cva } from 'class-variance-authority'
export { default as Badge } from './Badge.vue'
export const badgeVariants = cva('inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2', {
    variants: { variant: { default: 'border-transparent bg-primary text-primary-foreground hover:bg-primary/80', secondary: 'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80', destructive: 'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80', outline: 'text-foreground border-input',
    // NUOVE VARIANTI PERSONALIZZATE PER I BADGE DEGLI UFFICI (con text-white)
    contabilita: 'border-transparent bg-rose-500 text-white', // Rosso Rosato per ContabilitÃ 
    supportoTecnico: 'border-transparent bg-lime-500 text-white', // Verde Lime per Supporto Tecnico
    segreteria: 'border-transparent bg-violet-500 text-white', // Viola per Segreteria
    } },
    defaultVariants: { variant: 'default' },
})
export type BadgeVariants = VariantProps<typeof badgeVariants>


================================================
FILE: components/ui/button/button.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { Primitive, type PrimitiveProps } from 'radix-vue'
import { type ButtonVariants, buttonVariants } from '.'
import { cn } from '@/lib/utils'
interface Props extends /* @vue-ignore */ PrimitiveProps { variant?: ButtonVariants['variant']; size?: ButtonVariants['size']; class?: HTMLAttributes['class'] }
const props = withDefaults(defineProps<Props>(), { as: 'button' })
</script>
<template>
  <Primitive :as="as" :as-child="asChild" :class="cn(buttonVariants({ variant, size }), props.class)"><slot /></Primitive>
</template>


================================================
FILE: components/ui/button/index.ts
================================================
import { type VariantProps, cva } from 'class-variance-authority'
export { default as Button } from './button.vue'
export const buttonVariants = cva('inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50', {
    variants: {
        variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
        // NUOVA VARIANTE: Sfondo nero, testo bianco
        black: 'bg-black text-white hover:bg-black/90',
        },
        size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
        },
    },
    defaultVariants: { variant: 'default', size: 'default' },
})
export type ButtonVariants = VariantProps<typeof buttonVariants>


================================================
FILE: components/ui/card/Card.vue
================================================
<template><div :class="cn('rounded-lg border bg-card text-card-foreground shadow-sm', props.class)"><slot /></div></template>
<script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; 
const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardContent.vue
================================================
<template><div :class="cn('p-6 pt-0', props.class)"><slot /></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardDescription.vue
================================================
<template><p :class="cn('text-sm text-muted-foreground', props.class)"><slot /></p></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardFooter.vue
================================================
<template><div :class="cn('flex items-center p-6 pt-0', props.class)"><slot /></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardHeader.vue
================================================
<template><div :class="cn('flex flex-col space-y-1.5 p-6', props.class)"><slot /></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/CardTitle.vue
================================================
<template><h3 :class="cn('text-2xl font-semibold leading-none tracking-tight', props.class)"><slot /></h3></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/card/index.ts
================================================
export { default as Card } from './Card.vue'
export { default as CardHeader } from './CardHeader.vue'
export { default as CardTitle } from './CardTitle.vue'
export { default as CardDescription } from './CardDescription.vue'
export { default as CardContent } from './CardContent.vue'
export { default as CardFooter } from './CardFooter.vue'


================================================
FILE: components/ui/dialog/Dialog.vue
================================================
<script setup lang="ts">
import { DialogRoot, type DialogRootEmits, type DialogRootProps, useForwardPropsEmits } from 'radix-vue'
const props = defineProps</* @vue-ignore */ DialogRootProps>() // Aggiungi qui
const emits = defineEmits<DialogRootEmits>()
const forwarded = useForwardPropsEmits(props, emits)
</script>
<template><DialogRoot v-bind="forwarded"><slot /></DialogRoot></template>


================================================
FILE: components/ui/dialog/DialogClose.vue
================================================
<script setup lang="ts">
import { DialogClose, type DialogCloseProps } from 'radix-vue' // <-- CAMBIATO DA reka-ui a radix-vue

const props = defineProps</* @vue-ignore */ DialogCloseProps>()
</script>

<template>
  <DialogClose v-bind="props">
    <slot />
  </DialogClose>
</template>


================================================
FILE: components/ui/dialog/DialogContent.vue
================================================
<script setup lang="ts">
import { type HTMLAttributes, computed } from 'vue'
import { DialogClose, DialogContent, type DialogContentEmits, type DialogContentProps, DialogOverlay, DialogPortal, useForwardPropsEmits } from 'radix-vue'
import { X } from 'lucide-vue-next'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ DialogContentProps & { class?: HTMLAttributes['class'] }>()
const emits = defineEmits<DialogContentEmits>()
const delegatedProps = computed(() => { const { class: _, ...delegated } = props; return delegated })
const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>
<template>
  <DialogPortal>
    <DialogOverlay class="fixed inset-0 z-50 bg-black/80" />
    <!-- MODIFICA QUI: Aggiunto bg-white !important e dark:bg-white !important dark:text-black !important -->
    <DialogContent v-bind="forwarded" :class="cn('fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-white !important p-6 shadow-lg duration-200 sm:rounded-lg dark:bg-white !important dark:text-black !important', props.class)">
      <slot />
      <DialogClose class="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
        <X class="h-4 w-4" />
        <span class="sr-only">Close</span>
      </DialogClose>
    </DialogContent>
  </DialogPortal>
</template>


================================================
FILE: components/ui/dialog/DialogDescription.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { DialogDescription, type DialogDescriptionProps } from 'radix-vue'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ DialogDescriptionProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui
</script>
<template><DialogDescription :class="cn('text-sm text-muted-foreground', props.class)" v-bind="props"><slot /></DialogDescription></template>


================================================
FILE: components/ui/dialog/DialogFooter.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'
const props = defineProps<{ class?: HTMLAttributes['class'] }>()
</script>
<template><div :class="cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', props.class)"><slot /></div></template>


================================================
FILE: components/ui/dialog/DialogHeader.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'
const props = defineProps<{ class?: HTMLAttributes['class'] }>()
</script>
<template><div :class="cn('flex flex-col space-y-1.5 text-center sm:text-left', props.class)"><slot /></div></template>


================================================
FILE: components/ui/dialog/DialogScrollContent.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { X } from 'lucide-vue-next'
import {
  DialogClose,
  DialogContent, // Questo ora viene da radix-vue!
  type DialogContentEmits,
  type DialogContentProps,
  DialogOverlay, // Questo ora viene da radix-vue!
  DialogPortal, // Questo ora viene da radix-vue!
  useForwardPropsEmits,
} from 'radix-vue' // <-- CAMBIATO DA reka-ui a radix-vue
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ DialogContentProps & { class?: HTMLAttributes['class'] }>()
const emits = defineEmits<DialogContentEmits>()
const delegatedProps = reactiveOmit(props, 'class')
const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <DialogPortal>
    <DialogOverlay
      class="fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
    >
      <DialogContent
        :class="
          cn(
            'relative z-50 grid w-full max-w-lg my-8 gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full',
            props.class,
          )
        "
        v-bind="forwarded"
        @pointer-down-outside="(event) => {
          const originalEvent = event.detail.originalEvent;
          const target = originalEvent.target as HTMLElement;
          if (originalEvent.offsetX > target.clientWidth || originalEvent.offsetY > target.clientHeight) {
            event.preventDefault();
          }
        }"
      >
        <slot />

        <DialogClose
          class="absolute top-4 right-4 p-0.5 transition-colors rounded-md hover:bg-secondary"
        >
          <X class="w-4 h-4" />
          <span class="sr-only">Close</span>
        </DialogClose>
      </DialogContent>
    </DialogOverlay>
  </DialogPortal>
</template>


================================================
FILE: components/ui/dialog/DialogTitle.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { DialogTitle, type DialogTitleProps } from 'radix-vue'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ DialogTitleProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui
</script>
<template><DialogTitle v-bind="props" :class="cn('text-lg font-semibold leading-none tracking-tight', props.class)"><slot /></DialogTitle></template>


================================================
FILE: components/ui/dialog/DialogTrigger.vue
================================================
<script setup lang="ts">
import { DialogTrigger, type DialogTriggerProps } from 'radix-vue'
const props = defineProps</* @vue-ignore */ DialogTriggerProps>() // Aggiungi qui
</script>
<template><DialogTrigger v-bind="props"><slot /></DialogTrigger></template>


================================================
FILE: components/ui/dialog/index.ts
================================================
// File: components/ui/dialog/index.ts
export { default as Dialog } from './Dialog.vue'
export { default as DialogClose } from './DialogClose.vue'
export { default as DialogContent } from './DialogContent.vue'
export { default as DialogDescription } from './DialogDescription.vue'
export { default as DialogFooter } from './DialogFooter.vue'
export { default as DialogHeader } from './DialogHeader.vue'
export { default as DialogScrollContent } from './DialogScrollContent.vue'
export { default as DialogTitle } from './DialogTitle.vue'
export { default as DialogTrigger } from './DialogTrigger.vue'


================================================
FILE: components/ui/input/index.ts
================================================
export { default as Input } from './Input.vue'



================================================
FILE: components/ui/input/Input.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { useVModel } from '@vueuse/core'
import { cn } from '@/lib/utils'
const props = defineProps<{ defaultValue?: string | number; modelValue?: string | number; class?: HTMLAttributes['class'] }>()
const emits = defineEmits<{ (e: 'update:modelValue', payload: string | number): void }>()
const modelValue = useVModel(props, 'modelValue', emits, { passive: true, defaultValue: props.defaultValue })
</script>
<template><input v-model="modelValue" :class="cn('flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50', props.class)"></template>


================================================
FILE: components/ui/label/index.ts
================================================
// File: components/ui/label/index.ts
export { default as Label } from './Label.vue'


================================================
FILE: components/ui/label/Label.vue
================================================
<script setup lang="ts">
import { type HTMLAttributes, type LabelHTMLAttributes } from 'vue'
import { Label, type LabelProps } from 'radix-vue'
import { cn } from '@/lib/utils'
const props = defineProps</* @vue-ignore */ LabelProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui
</script>
<template><Label :class="cn('text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70', props.class)"><slot /></Label></template>


================================================
FILE: components/ui/table/index.ts
================================================
// File: components/ui/table/index.ts

export { default as Table } from './Table.vue'
export { default as TableHeader } from './TableHeader.vue'
export { default as TableBody } from './TableBody.vue' // Assicurati che sia .vue
export { default as TableRow } from './TableRow.vue'
export { default as TableHead } from './TableHead.vue'
export { default as TableCell } from './TableCell.vue'


================================================
FILE: components/ui/table/Table.vue
================================================
<template><div class="relative w-full overflow-auto"><table :class="cn('w-full caption-bottom text-sm', props.class)"><slot /></table></div></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableBody.vue
================================================
<template><tbody :class="cn('[&_tr:last-child]:border-0', props.class)"><slot /></tbody></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableCaption.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'

const props = defineProps<{
  class?: HTMLAttributes['class']
}>()
</script>

<template>
  <caption :class="cn('mt-4 text-sm text-muted-foreground', props.class)">
    <slot />
  </caption>
</template>



================================================
FILE: components/ui/table/TableCell.vue
================================================
<template><td :class="cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', props.class)"><slot /></td></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableEmpty.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { cn } from '@/lib/utils'
import TableCell from './TableCell.vue'
import TableRow from './TableRow.vue'

const props = withDefaults(defineProps<{
  class?: HTMLAttributes['class']
  colspan?: number
}>(), {
  colspan: 1,
})

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <TableRow>
    <TableCell
      :class="
        cn(
          'p-4 whitespace-nowrap align-middle text-sm text-foreground',
          props.class,
        )
      "
      v-bind="delegatedProps"
    >
      <div class="flex items-center justify-center py-10">
        <slot />
      </div>
    </TableCell>
  </TableRow>
</template>



================================================
FILE: components/ui/table/TableFooter.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'

const props = defineProps<{
  class?: HTMLAttributes['class']
}>()
</script>

<template>
  <tfoot :class="cn('border-t bg-muted/50 font-medium [&>tr]:last:border-b-0', props.class)">
    <slot />
  </tfoot>
</template>



================================================
FILE: components/ui/table/TableHead.vue
================================================
<template><th :class="cn('h-8 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0', props.class)"><slot /></th></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/table/TableHeader.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { cn } from '@/lib/utils'

const props = defineProps<{
  class?: HTMLAttributes['class']
}>()
</script>

<template>
  <th :class="cn('h-8 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5', props.class)">
    <slot />
  </th>
</template>


================================================
FILE: components/ui/table/TableRow.vue
================================================
<template><tr :class="cn('border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted', props.class)"><slot /></tr></template><script setup lang="ts">import type { HTMLAttributes } from 'vue'; import { cn } from '@/lib/utils'; const props = defineProps<{ class?: HTMLAttributes['class'] }>() </script>


================================================
FILE: components/ui/textarea/index.ts
================================================
// File: components/ui/textarea/index.ts
export { default as Textarea } from './Textarea.vue'


================================================
FILE: components/ui/textarea/Textarea.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { useVModel } from '@vueuse/core'
import { cn } from '@/lib/utils'
const props = defineProps<{ class?: HTMLAttributes['class']; defaultValue?: string | number; modelValue?: string | number }>()
const emits = defineEmits<(e: 'update:modelValue', payload: string | number) => void>()
const modelValue = useVModel(props, 'modelValue', emits, { passive: true, defaultValue: props.defaultValue })
</script>
<template><textarea v-model="modelValue" :class="cn('flex min-h-20 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50', props.class)" /></template>


================================================
FILE: components/ui/toast/index.ts
================================================
import type { ToastRootProps } from 'reka-ui'
import type { HTMLAttributes } from 'vue'

export { default as Toast } from './Toast.vue'
export { default as ToastAction } from './ToastAction.vue'
export { default as ToastClose } from './ToastClose.vue'
export { default as ToastDescription } from './ToastDescription.vue'
export { default as Toaster } from './Toaster.vue'
export { default as ToastProvider } from './ToastProvider.vue'
export { default as ToastTitle } from './ToastTitle.vue'
export { default as ToastViewport } from './ToastViewport.vue'
export { toast, useToast } from './use-toast'

import { cva, type VariantProps } from 'class-variance-authority'

export interface ToastProps extends /* @vue-ignore */ ToastRootProps {
  class?: HTMLAttributes['class']
  variant?: ToastVariants['variant']
  onOpenChange?: ((value: boolean) => void) | undefined
}

export const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--reka-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--reka-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
                    'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

type ToastVariants = VariantProps<typeof toastVariants>

export interface ToastProps extends ToastRootProps {
  class?: HTMLAttributes['class']
  variant?: ToastVariants['variant']
  onOpenChange?: ((value: boolean) => void) | undefined
}



================================================
FILE: components/ui/toast/Toast.vue
================================================
<script setup lang="ts">
import { reactiveOmit } from '@vueuse/core'
import { ToastRoot, type ToastRootEmits, useForwardPropsEmits } from 'reka-ui'
import { cn } from '@/lib/utils'
import { type ToastProps, toastVariants } from '.'

const props = defineProps</* @vue-ignore */ ToastProps>() // Aggiungi qui

const emits = defineEmits<ToastRootEmits>()

const delegatedProps = reactiveOmit(props, 'class')

const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <ToastRoot
    v-bind="forwarded"
    :class="cn(toastVariants({ variant }), props.class)"
    @update:open="onOpenChange"
  >
    <slot />
  </ToastRoot>
</template>



================================================
FILE: components/ui/toast/ToastAction.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastAction, type ToastActionProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastActionProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastAction v-bind="delegatedProps" :class="cn('inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive', props.class)">
    <slot />
  </ToastAction>
</template>



================================================
FILE: components/ui/toast/ToastClose.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { X } from 'lucide-vue-next'
import { ToastClose, type ToastCloseProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastCloseProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastClose v-bind="delegatedProps" :class="cn('absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600', props.class)">
    <X class="h-4 w-4" />
  </ToastClose>
</template>



================================================
FILE: components/ui/toast/ToastDescription.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastDescription, type ToastDescriptionProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastDescriptionProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastDescription :class="cn('text-sm opacity-90', props.class)" v-bind="delegatedProps">
    <slot />
  </ToastDescription>
</template>



================================================
FILE: components/ui/toast/Toaster.vue
================================================
<script setup lang="ts">
import { isVNode } from 'vue'
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from '.'
import { useToast } from './use-toast'

const { toasts } = useToast()
</script>

<template>
  <ToastProvider>
    <Toast v-for="toast in toasts" :key="toast.id" v-bind="toast">
      <div class="grid gap-1">
        <ToastTitle v-if="toast.title">
          {{ toast.title }}
        </ToastTitle>
        <template v-if="toast.description">
          <ToastDescription v-if="isVNode(toast.description)">
            <component :is="toast.description" />
          </ToastDescription>
          <ToastDescription v-else>
            {{ toast.description }}
          </ToastDescription>
        </template>
        <ToastClose />
      </div>
      <component :is="toast.action" />
    </Toast>
    <ToastViewport />
  </ToastProvider>
</template>



================================================
FILE: components/ui/toast/ToastProvider.vue
================================================
<script setup lang="ts">
import { ToastProvider, type ToastProviderProps } from 'reka-ui'

const props = defineProps</* @vue-ignore */ ToastProviderProps>() // Aggiungi qui
</script>

<template>
  <ToastProvider v-bind="props">
    <slot />
  </ToastProvider>
</template>



================================================
FILE: components/ui/toast/ToastTitle.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastTitle, type ToastTitleProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastTitleProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastTitle v-bind="delegatedProps" :class="cn('text-sm font-semibold [&+div]:text-xs', props.class)">
    <slot />
  </ToastTitle>
</template>



================================================
FILE: components/ui/toast/ToastViewport.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from 'vue'
import { reactiveOmit } from '@vueuse/core'
import { ToastViewport, type ToastViewportProps } from 'reka-ui'
import { cn } from '@/lib/utils'

const props = defineProps</* @vue-ignore */ ToastViewportProps & { class?: HTMLAttributes['class'] }>() // Aggiungi qui

const delegatedProps = reactiveOmit(props, 'class')
</script>

<template>
  <ToastViewport
    v-bind="delegatedProps"
    :class="cn('fixed top-0 right-0 z-[100] flex max-h-screen w-full flex-col p-4 md:max-w-[420px]', props.class)"
  />
</template>


================================================
FILE: components/ui/toast/use-toast.ts
================================================
// components/ui/toast/use-toast.ts

import type { Component, VNode } from 'vue'
import type { ToastProps } from '.'
import { computed, ref } from 'vue'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 3000 // MODIFICA QUI: Da 1000000 a 3000

export type StringOrVNode =
  | string
  | VNode
  | (() => VNode)

type ToasterToast = ToastProps & {
  id: string
  title?: string
  description?: StringOrVNode
  action?: Component
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
    type: ActionType['ADD_TOAST']
    toast: ToasterToast
  }
  | {
    type: ActionType['UPDATE_TOAST']
    toast: Partial<ToasterToast>
  }
  | {
    type: ActionType['DISMISS_TOAST']
    toastId?: ToasterToast['id']
  }
  | {
    type: ActionType['REMOVE_TOAST']
    toastId?: ToasterToast['id']
  }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

function addToRemoveQueue(toastId: string) {
  if (toastTimeouts.has(toastId))
    return

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: actionTypes.REMOVE_TOAST,
      toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

const state = ref<State>({
  toasts: [],
})

function dispatch(action: Action) {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      state.value.toasts = [action.toast, ...state.value.toasts].slice(0, TOAST_LIMIT)
      break

    case actionTypes.UPDATE_TOAST:
      state.value.toasts = state.value.toasts.map(t =>
        t.id === action.toast.id ? { ...t, ...action.toast } : t,
      )
      break

    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      }
      else {
        state.value.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      state.value.toasts = state.value.toasts.map(t =>
        t.id === toastId || toastId === undefined
          ? {
              ...t,
              open: false,
            }
          : t,
      )
      break
    }

    case actionTypes.REMOVE_TOAST:
      if (action.toastId === undefined)
        state.value.toasts = []
      else
        state.value.toasts = state.value.toasts.filter(t => t.id !== action.toastId)

      break
  }
}

function useToast() {
  return {
    toasts: computed(() => state.value.toasts),
    toast,
    dismiss: (toastId?: string) => dispatch({ type: actionTypes.DISMISS_TOAST, toastId }),
  }
}

type Toast = Omit<ToasterToast, 'id'>

function toast(props: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: actionTypes.UPDATE_TOAST,
      toast: { ...props, id },
    })

  const dismiss = () => dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id })

  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open: boolean) => {
        if (!open)
          dismiss()
      },
    },
  })

  return {
    id,
    dismiss,
    update,
  }
}

export { toast, useToast }


================================================
FILE: lib/utils.ts
================================================
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'
export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)) }


================================================
FILE: pages/index.vue
================================================
<!-- File: pages/index.vue -->
<script setup>
import { ref, onMounted, computed, reactive } from 'vue';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

// Importa i componenti Dialog, Label, Input, Textarea necessari
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogClose } from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/components/ui/toast/use-toast';
import { Toaster } from '@/components/ui/toast';

// Importa le icone necessarie per l'infografica e per il pulsante Aggiorna
import { Mail, RefreshCw, Calculator, Settings, Calendar, Users } from 'lucide-vue-next';


// --- STATO DELLA PAGINA ---
const processedEmails = ref([]);
const selectedEmailContent = ref(null);
const showContentModal = ref(false);
const isLoading = ref(true);
const showAddStaffDialog = ref(false);

// Form per aggiungere nuovo staff
const newStaffForm = reactive({
  name: '',
  email: '',
  responsibilities: '',
});

const activeFilter = ref('all');

// Toast per notifiche
const { toast } = useToast();

const filteredEmails = computed(() => {
  if (!processedEmails.value || !Array.isArray(processedEmails.value)) {
    return [];
  }
  return processedEmails.value;
});

const totalEmailsCount = computed(() => processedEmails.value ? processedEmails.value.length : 0);
const forwardedToContabilitaCount = computed(() => {
  return processedEmails.value.filter(e => e.status === 'forwarded' && e.staff?.name === 'Ufficio ContabilitÃ ').length;
});
const forwardedToSupportoTecnicoCount = computed(() => {
  return processedEmails.value.filter(e => e.status === 'forwarded' && e.staff?.name === 'Supporto Tecnico').length;
});
const forwardedToSegreteriaCount = computed(() => {
  return processedEmails.value.filter(e => e.status === 'forwarded' && e.staff?.name === 'Segreteria Generale').length;
});


// --- FUNZIONI PRINCIPALI ---
const fetchProcessedEmails = async () => {
  isLoading.value = true;
  try {
    const data = await $fetch('/api/inbox');
    processedEmails.value = data || [];
  }
  catch (error) {
    console.error("Impossibile caricare la posta smistata:", error);
    toast({
      title: 'Errore',
      description: 'Impossibile caricare lo storico delle email.',
      variant: 'destructive',
    });
    processedEmails.value = [];
  }
  finally {
    isLoading.value = false;
  }
};

const viewEmailContent = (email) => {
  selectedEmailContent.value = email;
  showContentModal.value = true;
};

const addStaff = async () => {
  console.log('addStaff function called'); // Lasciamo il log per verifica
  try {
    const response = await $fetch('/api/staff', {
      method: 'POST',
      body: newStaffForm,
    });
    
    if (response.status === 'success') {
      toast({
        title: 'Successo!',
        description: 'Dipendente aggiunto e salvato nel database.',
      });
      showAddStaffDialog.value = false;
      Object.assign(newStaffForm, { name: '', email: '', responsibilities: '' });
      await fetchProcessedEmails();

    } else {
      toast({
        title: 'Errore',
        description: response.message || 'Errore durante l\'aggiunta del dipendente.',
        variant: 'destructive',
      });
    }
  } catch (error) {
    console.error('Errore durante l\'aggiunta del dipendente:', error);
    toast({
      title: 'Errore',
      description: error.data?.statusMessage || 'Si Ã¨ verificato un errore imprevisto.',
      variant: 'destructive',
    });
  }
};

// --- FUNZIONI UTILI PER LA GRAFICA E I BADGE ---
const formatDate = (dateString) => {
  if (!dateString) return 'N/D';
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return 'Data non valida';
  const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
  return date.toLocaleString('it-IT', options);
};

const getConfidenceVariant = (score) => {
  if (score === null || score === undefined) return 'secondary';
  if (score >= 0.8) return 'default';
  if (score >= 0.5) return 'secondary';
  return 'destructive';
};

const getStatusLabel = (status) => {
  switch (status) {
    case 'new': return 'Nuova';
    case 'analyzed': return 'Analizzata';
    case 'forwarded': return 'Inoltrata';
    case 'manual_review': return 'Revisione Manuale';
    case 'ai_error': return 'Errore AI';
    case 'forward_error': return 'Errore Inoltro';
    default: return status;
  }
};

const getStaffBadgeVariant = (staffName) => {
  switch (staffName) {
    case 'Ufficio ContabilitÃ ': return 'contabilita';
    case 'Supporto Tecnico': return 'supportoTecnico';
    case 'Segreteria Generale': return 'segreteria';
    default: return 'outline';
  }
};

// --- HOOK ---
onMounted(async () => {
  await fetchProcessedEmails();
});
</script>

<template>
  <div class="container mx-auto p-4 md:p-8 space-y-8">
    <Toaster />

    <h1 class="text-2xl font-bold mb-4">Gestione Email Intelligente</h1>

    <!-- SEZIONE: INFOGRAFICA (CARTE GRANDI IN ALTO, SOLO TITOLO E NUMERO) -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
      <Card class="bg-gradient-to-br from-blue-50 to-gray-100">
        <CardHeader class="flex flex-row items-center justify-between space-y-0 pb-2 text-gray-800">
          <CardTitle class="text-sm font-medium">
            Email Totali
          </CardTitle>
          <Mail class="h-4 w-4 text-gray-700" />
        </CardHeader>
        <CardContent class="text-gray-800">
          <div class="text-2xl font-bold">
            {{ totalEmailsCount }}
          </div>
        </CardContent>
      </Card>

      <Card class="bg-gradient-to-br from-rose-200 to-red-400">
        <CardHeader class="flex flex-row items-center justify-between space-y-0 pb-2 text-black">
          <CardTitle class="text-sm font-medium">
            Email ContabilitÃ 
          </CardTitle>
          <Calculator class="h-4 w-4 text-gray-800" />
        </CardHeader>
        <CardContent class="text-black">
          <div class="text-2xl font-bold">
            {{ forwardedToContabilitaCount }}
          </div>
        </CardContent>
      </Card>

      <Card class="bg-gradient-to-br from-lime-200 to-green-400">
        <CardHeader class="flex flex-row items-center justify-between space-y-0 pb-2 text-black">
          <CardTitle class="text-sm font-medium">
            Email Supporto Tecnico
          </CardTitle>
          <Settings class="h-4 w-4 text-gray-800" />
        </CardHeader>
        <CardContent class="text-black">
          <div class="text-2xl font-bold">
            {{ forwardedToSupportoTecnicoCount }}
          </div>
        </CardContent>
      </Card>

      <Card class="bg-gradient-to-br from-purple-200 to-fuchsia-300">
        <CardHeader class="flex flex-row items-center justify-between space-y-0 pb-2 text-black">
          <CardTitle class="text-sm font-medium">
            Email Segreteria
          </CardTitle>
          <Calendar class="h-4 w-4 text-gray-800" />
        </CardHeader>
        <CardContent class="text-black">
          <div class="text-2xl font-bold">
            {{ forwardedToSegreteriaCount }}
          </div>
        </CardContent>
      </Card>
    </div>
    <!-- FINE SEZIONE INFOGRAFICA -->

    <!-- Pulsante "Aggiungi Dipendente/Ufficio" (allineato a destra) -->
    <div class="flex justify-end mb-4">
      <Button variant="outline" @click="showAddStaffDialog = true" class="shrink-0">
        <Users class="h-4 w-4 mr-2" />
        Aggiungi Dipendente/Ufficio
      </Button>
    </div>

    <Card>
      <CardHeader>
        <CardTitle>Posta Smistata dall'AI</CardTitle>
        <CardDescription>Elenco delle email analizzate e assegnate a un dipartimento responsabile.</CardDescription>
      </CardHeader>
      <CardContent>
        <!-- TOOLBAR: SOLO PULSANTE AGGIORNA ALLINEATO A DESTRA (FILTRI RIMOSSI) -->
        <div class="flex justify-end mb-4">
          <Button variant="outline" @click="fetchProcessedEmails" :disabled="isLoading" class="shrink-0">
            <RefreshCw class="h-4 w-4 mr-2" />
            Aggiorna
          </Button>
        </div>

        <!-- Stato di Caricamento/Vuoto della Tabella -->
        <div v-if="isLoading" class="text-center py-16">
          <p class="text-muted-foreground">Caricamento storico email...</p>
        </div>
        <div v-else-if="filteredEmails.length > 0">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Mittente & Oggetto</TableHead>
                <TableHead>Etichetta (Assegnato A)</TableHead>
                <TableHead class="text-center">Confidenza AI</TableHead>
                <TableHead class="text-center">Stato</TableHead>
                <TableHead class="text-right">Ricevuta il</TableHead>
                <TableHead class="text-center">Contenuto</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              <TableRow v-for="email in filteredEmails" :key="email.id">
                <TableCell class="font-medium">
                  <div>{{ email.sender }}</div>
                  <div class="text-xs text-muted-foreground truncate max-w-xs" :title="email.subject">{{ email.subject }}</div>
                </TableCell>
                <TableCell>
                  <Badge :variant="getStaffBadgeVariant(email.staff?.name)">
                    {{ email.staff?.name || 'Non Assegnato' }}
                  </Badge>
                </TableCell>
                <TableCell class="text-center">
                  <Badge :variant="getConfidenceVariant(email.ai_confidence_score)">
                    {{ email.ai_confidence_score !== null && email.ai_confidence_score !== undefined ? (email.ai_confidence_score * 100).toFixed(0) + '%' : 'N/D' }}
                  </Badge>
                </TableCell>
                <TableCell class="text-center">
                  <span>
                    {{ getStatusLabel(email.status) }}
                  </span>
                </TableCell>
                <TableCell class="text-right">{{ formatDate(email.created_at) }}</TableCell>
                <TableCell class="text-center">
                   <Button
                     @click="viewEmailContent(email)"
                     size="sm"
                     variant="black"
                   >
                     Visualizza
                   </Button>
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </div>
        <div v-else class="text-center py-16">
          <p class="text-muted-foreground">Nessuna email trovata per il filtro selezionata.</p>
          <p class="text-muted-foreground text-sm mt-2">Le email vengono elaborate automaticamente ogni 5 minuti.</p>
        </div>
      </CardContent>
    </Card>
    
    <!-- Modale per visualizzare contenuto email -->
    <Dialog :open="showContentModal" @update:open="showContentModal = false">
      <DialogContent v-if="selectedEmailContent" class="dialog-content-force-white">
          <DialogHeader>
              <DialogTitle>{{ selectedEmailContent.subject }}</DialogTitle>
              <DialogDescription>Da: {{ selectedEmailContent.sender }}</DialogDescription>
          </DialogHeader>
          <div class="py-4 whitespace-pre-wrap text-sm max-h-96 overflow-y-auto">
              {{ selectedEmailContent.body_text || "Corpo dell'email non disponibile." }}
          </div>
          <DialogFooter>
              <Button @click="showContentModal = false" variant="outline">Chiudi</Button>
          </DialogFooter>
      </DialogContent>
    </Dialog>

    <!-- Modale per Aggiungere Nuovo Dipendente/Ufficio -->
    <Dialog :open="showAddStaffDialog" @update:open="showAddStaffDialog = $event">
      <DialogContent class="dialog-content-force-white">
        <DialogHeader>
          <DialogTitle>Aggiungi Nuovo Dipendente/Ufficio</DialogTitle>
          <DialogDescription>
            Inserisci i dettagli del nuovo membro dello staff o del nuovo ufficio.
          </DialogDescription>
        </DialogHeader>
        <form> <!-- RIMOSSO @submit.prevent dal form -->
          <div class="grid gap-4 py-4">
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="name" class="text-right">
                Nome Ufficio / Dipendente
              </Label>
              <Input id="name" v-model="newStaffForm.name" required class="col-span-3" />
            </div>
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="email" class="text-right">
                Email
              </Label>
              <Input id="email" type="email" v-model="newStaffForm.email" required class="col-span-3" />
            </div>
            <div class="grid grid-cols-4 items-center gap-4">
              <Label for="responsibilities" class="text-right">
                ResponsabilitÃ 
              </Label>
              <Textarea id="responsibilities" v-model="newStaffForm.responsibilities" required class="col-span-3" />
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" @click="showAddStaffDialog = false">Annulla</Button>
            <!-- COLLEGATO addStaff direttamente all'evento @click -->
            <Button type="button" @click="addStaff">Aggiungi</Button> 
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>

  </div>
</template>


================================================
FILE: public/robots.txt
================================================
User-Agent: *
Disallow:



================================================
FILE: server/tsconfig.json
================================================
{
  "extends": "../.nuxt/tsconfig.server.json"
}



================================================
FILE: server/api/inbox.get.js
================================================
// File: server/api/inbox.get.js

import { defineEventHandler } from 'h3';
import { serverSupabaseClient } from '#supabase/server';

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event);

  const { data, error } = await supabase
    .from('incoming_emails')
    .select(`
      id, created_at, sender, subject, body_text, status,
      ai_confidence_score, ai_reasoning,
      staff:assigned_to_staff_id ( id, name, email )
    `)
    .order('created_at', { ascending: false });

  if (error) throw createError({ statusCode: 500, statusMessage: error.message });
  return data;
});


================================================
FILE: server/api/staff.get.js
================================================
// server/api/staff.get.js

import { defineEventHandler } from 'h3';
import { serverSupabaseClient } from '#supabase/server';

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event);

  const { data, error } = await supabase
    .from('staff')
    .select('id, name, email, responsibilities')
    .order('name', { ascending: true });

  if (error) {
    console.error('Supabase staff fetch error:', error.message);
    throw createError({ statusCode: 500, statusMessage: error.message });
  }

  return data;
});


================================================
FILE: server/api/staff.post.js
================================================
// server/api/staff.post.js

import { defineEventHandler, readBody, createError } from 'h3';
import { getSupabaseAdminClient } from '../utils/supabaseAdmin'; // PERCORSO CORRETTO

export default defineEventHandler(async (event) => {
  const supabaseAdmin = getSupabaseAdminClient();
  const body = await readBody(event);
  const { name, email, responsibilities } = body;

  if (!name || !email || !responsibilities) {
    throw createError({ statusCode: 400, statusMessage: 'Nome, email e responsabilitÃ  sono campi obbligatori.' });
  }

  try {
    const { data, error } = await supabaseAdmin
      .from('staff')
      .insert({
        name: name,
        email: email,
        responsibilities: responsibilities,
      })
      .select()
      .single();

    if (error) {
      console.error('Supabase staff insert error:', error.message);
      throw createError({ statusCode: 500, statusMessage: `Errore durante l'aggiunta del dipendente: ${error.message}` });
    }

    return { status: 'success', message: 'Dipendente aggiunto con successo!', data: data };
  } catch (e) {
    console.error('Errore nel processare la richiesta POST per staff:', e);
    throw createError({ statusCode: e.statusCode || 500, statusMessage: e.statusMessage || 'Errore interno del server.' });
  }
});


================================================
FILE: server/api/emails/process.post.js
================================================
// File: server/api/emails/process.post.js

import { defineEventHandler, readBody, createError, setResponseStatus } from 'h3';
import { serverSupabaseClient } from '#supabase/server'; // Per accedere al client Supabase (con chiave anonima)
import { analyzeEmailWithAI } from '../../utils/aiService'; // Funzione centralizzata per l'analisi AI
import { sendEmail } from '../../utils/emailSender';     // Funzione centralizzata per l'invio email

export default defineEventHandler(async (event) => {
  const supabase = await serverSupabaseClient(event); // Client Supabase per operazioni DB
  const body = await readBody(event);
  const { sender, subject, body_text } = body;

  if (!sender || !subject || !body_text) {
    throw createError({ statusCode: 400, statusMessage: 'Mittente, oggetto o corpo email mancanti.' });
  }

  let emailRecordId = null; // ID dell'email nel DB, per aggiornamenti successivi

  try {
    // 1. Salva l'email nel database con stato 'new'
    const { data: savedEmail, error: saveError } = await supabase.from('incoming_emails').insert([{
        sender: sender,
        subject: subject,
        body_text: body_text,
        // body_html: null, // Non abbiamo HTML dal form manuale, quindi null
        status: 'new',
    }]).select().single();

    if (saveError) {
        console.error('API Supabase save error (process.post):', saveError.message);
        throw createError({ statusCode: 500, statusMessage: `Errore durante il salvataggio dell'email: ${saveError.message}` });
    }
    emailRecordId = savedEmail.id;
    console.log(`Manual email saved to DB with ID: ${emailRecordId}`);

    // 2. Analisi AI
    const aiResult = await analyzeEmailWithAI(sender, subject, body_text);
    
    // 3. Aggiorna l'email nel DB con i risultati dell'AI
    const newStatus = aiResult.assigned_to_staff_id ? 'analyzed' : 'manual_review';
    const { error: updateError } = await supabase.from('incoming_emails').update({
        assigned_to_staff_id: aiResult.assigned_to_staff_id,
        ai_confidence_score: aiResult.ai_confidence_score,
        ai_reasoning: aiResult.ai_reasoning,
        status: newStatus,
    }).eq('id', emailRecordId);

    if (updateError) {
        console.error('API Supabase AI update error (process.post):', updateError.message);
        throw createError({ statusCode: 500, statusMessage: `Errore durante l'aggiornamento AI dell'email: ${updateError.message}` });
    }
    console.log(`AI analysis updated for manual email ID ${emailRecordId}. Assigned to staff: ${aiResult.assigned_to_staff_id || 'N/A'}`);

    // 4. Se l'AI ha assegnato e trovato un'email, inoltra l'email
    let assignedStaffMember = null;
    if (aiResult.assigned_to_staff_id && aiResult.assignedStaffEmail) {
        try {
            await sendEmail(
                aiResult.assignedStaffEmail,
                sender.split('<')[0].trim() || sender, // Nome dal mittente originale
                sender, // Email mittente originale
                subject,
                body_text, // Invia il testo originale
                aiResult.ai_reasoning
            );
            // Aggiorna lo stato a 'forwarded'
            await supabase.from('incoming_emails').update({
                status: 'forwarded'
            }).eq('id', emailRecordId);

            assignedStaffMember = { 
                id: aiResult.assigned_to_staff_id, 
                name: aiResult.assignedStaffName, 
                email: aiResult.assignedStaffEmail 
            };
            console.log(`Manual email ID ${emailRecordId} successfully forwarded to ${aiResult.assignedStaffEmail}`);

        } catch (forwardError) {
            console.error('API Error during manual email forwarding (process.post):', forwardError);
            // Aggiorna lo stato a 'forward_error'
            await supabase.from('incoming_emails').update({
                status: 'forward_error'
            }).eq('id', emailRecordId);
            throw createError({ statusCode: 500, statusMessage: `Errore durante l'inoltro dell'email: ${forwardError.message}` });
        }
    } else {
        console.warn(`Manual email ID ${emailRecordId} not assigned by AI or missing staff email. Status set to 'manual_review'.`);
        // Lo stato Ã¨ giÃ  'manual_review' dal passo precedente
    }

    setResponseStatus(event, 200);
    return { 
      status: 'success',
      message: 'Email processata e assegnata con successo.', 
      assignment: assignedStaffMember, 
      emailRecord: savedEmail 
    };

  } catch (error) {
    console.error('Unhandled error in process.post.js:', error);
    setResponseStatus(event, error.statusCode || 500);
    return { 
        status: 'error',
        message: error.statusMessage || 'Si Ã¨ verificato un errore imprevisto.',
        details: error.message // Per dettagli nell'errore frontend
    };
  }
});


================================================
FILE: server/api/emails/webhook.post.js
================================================
// File: server/api/emails/webhook.post.js

import { defineEventHandler, readBody, createError, setResponseStatus } from 'h3';
import { serverSupabaseClient } from '#supabase/server'; // Per accedere al client Supabase (con chiave anonima)
import { analyzeEmailWithAI } from '../../utils/aiService'; // Funzione centralizzata per l'analisi AI
import { sendEmail } from '../../utils/emailSender';     // Funzione centralizzata per l'invio email

export default defineEventHandler(async (event) => {
    const supabase = await serverSupabaseClient(event); // Client Supabase per operazioni DB
    const payload = await readBody(event); // Il payload del webhook (es. da SendGrid Inbound Parse)

    // Estrai i dati dal payload (questi campi sono comuni nei webhook di parsing email)
    const senderRaw = payload.from || ''; 
    const senderEmail = senderRaw.match(/<(.+)>/)?.[1] || senderRaw; // Estrae solo l'email da "Nome <email@example.com>"
    const senderName = senderRaw.replace(/<.+>/, '').trim() || senderEmail;
    const subject = payload.subject || 'Nessun Oggetto';
    const body_text = payload.text || payload.html || 'Corpo email vuoto.';
    const body_html = payload.html || null;

    if (!senderEmail) {
      console.warn("Webhook ricevuto senza mittente valido. Ignorato.");
      setResponseStatus(event, 200); // Importante rispondere 200 OK per evitare re-invii da webhook
      return { status: "ignored", message: "Payload incompleto, email ignorata."};
    }

    let emailRecordId = null;

    try {
        // 1. Salva l'email nel database con stato 'new'
        const { data: savedEmail, error: saveError } = await supabase.from('incoming_emails').insert([{
            sender: senderEmail,
            subject: subject, 
            body_text: body_text, 
            body_html: body_html,
            status: 'new',
        }]).select().single();
        
        if (saveError) {
            console.error('Webhook Supabase save error (webhook.post):', saveError.message);
            throw new Error(`Errore Supabase (insert): ${saveError.message}`); // Rilancia per cattura successiva
        }
        emailRecordId = savedEmail.id;
        console.log(`Webhook email saved to DB with ID: ${emailRecordId}`);

        // 2. Analisi AI
        const aiResult = await analyzeEmailWithAI(senderEmail, subject, body_text);
        
        // 3. Aggiorna l'email nel DB con i risultati dell'AI
        const newStatus = aiResult.assigned_to_staff_id ? 'analyzed' : 'manual_review';
        const { error: updateError } = await supabase.from('incoming_emails').update({
            assigned_to_staff_id: aiResult.assigned_to_staff_id,
            ai_confidence_score: aiResult.ai_confidence_score,
            ai_reasoning: aiResult.ai_reasoning,
            status: newStatus,
        }).eq('id', emailRecordId);

        if (updateError) {
            console.error('Webhook Supabase AI update error (webhook.post):', updateError.message);
            throw new Error(`Errore Supabase (update AI): ${updateError.message}`);
        }
        console.log(`AI analysis updated for webhook email ID ${emailRecordId}. Assigned to staff: ${aiResult.assigned_to_staff_id || 'N/A'}`);

        // 4. Inoltra l'email al dipendente corretto
        if (aiResult.assigned_to_staff_id && aiResult.assignedStaffEmail) {
            try {
                await sendEmail(
                    aiResult.assignedStaffEmail,
                    senderName,
                    senderEmail,
                    subject,
                    body_text, // O body_html se preferisci, a seconda di sendEmail
                    aiResult.ai_reasoning
                );
                // Aggiorna lo stato a 'forwarded'
                await supabase.from('incoming_emails').update({
                    status: 'forwarded'
                }).eq('id', emailRecordId);
                console.log(`Webhook email ID ${emailRecordId} successfully forwarded to ${aiResult.assignedStaffEmail}`);

            } catch (forwardError) {
                console.error('Webhook Error during email forwarding (webhook.post):', forwardError);
                // Aggiorna lo stato a 'forward_error'
                await supabase.from('incoming_emails').update({
                    status: 'forward_error'
                }).eq('id', emailRecordId);
                throw forwardError; // Rilancia l'errore per il catch generale
            }
        } else {
            console.warn(`Webhook email ID ${emailRecordId} not assigned by AI or missing staff email. Status set to 'manual_review'.`);
            // Lo stato Ã¨ giÃ  'manual_review'
        }

        setResponseStatus(event, 200); // Sempre 200 OK per i webhook che hanno elaborato il messaggio
        return { status: 'success', message: `Email da ${senderEmail} processata e assegnata.` };

    } catch (error) {
        console.error('Unhandled error in webhook.post.js:', error);
        // Se c'Ã¨ un errore e emailRecordId Ã¨ noto, prova ad aggiornare lo stato a 'processing_error'
        if (emailRecordId) {
            await supabase.from('incoming_emails').update({
                status: 'processing_error',
                // error_message: error.message // Se hai un campo per i messaggi di errore
            }).eq('id', emailRecordId);
        }
        setResponseStatus(event, 200); // **IMPORTANTE:** Rispondi sempre 200 OK ai webhook per evitare re-invii continui, anche in caso di errore interno.
        return { status: 'error', message: `Errore interno durante l'elaborazione del webhook: ${error.message}` };
    }
});


================================================
FILE: server/plugins/scheduler.js
================================================
// server/plugins/scheduler.js
import { Cron } from 'croner';
import { processNewIncomingEmails } from '../utils/mailProcessor';

export default defineNitroPlugin(async (nitroApp) => {
  // Gestore globale per gli errori di Promise non catturati (unhandledRejection).
  process.on('unhandledRejection', (reason, promise) => {
    console.error('GLOBAL ERROR: Unhandled Rejection at Promise', promise, 'reason:', reason);
  });

  // Esegui la funzione di elaborazione email all'avvio del server Nitro.
  console.log('Initial email processing run on server start.');
  try {
    await processNewIncomingEmails();
  } catch (error) {
    console.error('Error during initial email processing run:', error);
  }

  // Programma l'esecuzione periodica della funzione di elaborazione email.
  console.log('Email processing scheduler started and scheduled to run every  minute.');
  
  // *** MODIFICA QUI: Aggiungi "new" prima di Cron() ***
  new Cron('*/1 * * * *', async () => { 
    console.log('Running scheduled email processing (every  minute)...');
    try {
      await processNewIncomingEmails();
    } catch (error) {
      console.error('Error during scheduled email processing run:', error);
    }
  }, { timezone: 'Europe/Rome' });


});


================================================
FILE: server/utils/aiService.js
================================================
// server/utils/aiService.js
import { useRuntimeConfig } from '#imports';
import { $fetch } from 'ofetch';
// Usiamo il client admin per fetch staff
import { getSupabaseAdminClient } from './supabaseAdmin'; 

const config = useRuntimeConfig();
const GOOGLE_API_KEY = config.googleApiKey;
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GOOGLE_API_KEY}`;

const PROMPT_EMAIL_TRIAGE = `
Sei un assistente AI super efficiente per uno studio di commercialisti. Il tuo compito Ã¨ analizzare un'email in arrivo e assegnarla al membro dello staff piÃ¹ appropriato.

Ecco la lista del personale e delle loro responsabilitÃ :
--- LISTA PERSONALE ---
{staff_list}
-----------------------

Analizza il seguente contenuto dell'email (mittente, oggetto e corpo) e determina quale persona dello staff Ã¨ il piÃ¹ adatto a gestirla.

--- CONTENUTO EMAIL ---
Mittente: {email_from}
Oggetto: {email_subject}
Corpo: {email_body}
-----------------------

La tua risposta DEVE essere un oggetto JSON con il seguente formato, senza alcun testo aggiuntivo:
{
  "assigned_to_staff_id": "l'UUID del dipendente scelto dalla lista. Se NESSUNO sembra appropriato, lascia null o l'UUID di un dipendente generico per 'segreteria generale' se ne hai uno predefinito.",
  "ai_confidence_score": un numero da 0.0 (per niente sicuro) a 1.0 (molto sicuro),
  "ai_reasoning": "Una breve frase che spiega perchÃ© hai scelto quel dipendente/ufficio. Esempio: 'L'email menziona problemi di accesso al software, che Ã¨ di competenza del Supporto Tecnico.'"
}
`;

export async function analyzeEmailWithAI(sender, subject, body_text) {
    const supabaseAdmin = getSupabaseAdminClient(); // Usa il client admin
    const { data: staff, error: staffError } = await supabaseAdmin.from('staff').select('id, name, responsibilities, email'); // Selezioniamo anche email
    if (staffError) {
        console.error('Error fetching staff for AI:', staffError.message);
        throw new Error('Impossibile caricare il personale per l\'analisi AI.');
    }
    if (!staff || staff.length === 0) {
        console.warn('Nessun personale configurato nel database per l\'analisi AI.');
        return {
            assigned_to_staff_id: null,
            ai_confidence_score: 0.1,
            ai_reasoning: "Nessun personale configurato per l'assegnazione.",
        };
    }

    const staffListForPrompt = staff.map(s => `ID: ${s.id}, Nome: ${s.name}, ResponsabilitÃ : ${s.responsibilities}, Email: ${s.email}`).join('\n');
    const finalPrompt = PROMPT_EMAIL_TRIAGE
        .replace('{staff_list}', staffListForPrompt)
        .replace('{email_from}', sender)
        .replace('{email_subject}', subject)
        .replace('{email_body}', body_text.substring(0, 4000));

    let aiResponse;
    try {
        const response = await $fetch.raw(GEMINI_API_URL, {
            method: 'POST', body: { contents: [{ parts: [{ text: finalPrompt }] }] }
        });
        const responseData = response._data;
        if (!responseData.candidates?.[0]?.content?.parts?.[0]?.text) {
            throw new Error('Risposta non valida o malformata da Gemini');
        }
        const rawJson = responseData.candidates[0].content.parts[0].text.replace(/```json/g, '').replace(/```/g, '').trim();
        aiResponse = JSON.parse(rawJson);
    } catch (e) {
        console.error("Errore chiamata Gemini:", e.message);
        throw new Error(`Errore durante l'analisi AI dell'email: ${e.message}`);
    }
    
    // Valida l'ID dello staff suggerito
    const bestMatchStaff = staff.find(s => s.id === aiResponse.assigned_to_staff_id);
    const finalAssignedId = bestMatchStaff ? aiResponse.assigned_to_staff_id : null;

    return {
        assigned_to_staff_id: finalAssignedId,
        ai_confidence_score: parseFloat(aiResponse.ai_confidence_score) || 0,
        ai_reasoning: aiResponse.ai_reasoning,
        assignedStaffEmail: bestMatchStaff?.email || null, // Aggiungiamo l'email dello staff qui
        assignedStaffName: bestMatchStaff?.name || null,
    };
}


================================================
FILE: server/utils/emailSender.js
================================================
// server/utils/emailSender.js
import sgMail from '@sendgrid/mail';
import { useRuntimeConfig } from '#imports';

const config = useRuntimeConfig();
sgMail.setApiKey(config.sendgridApiKey);

export async function sendEmail(to, fromName, fromAddress, subject, originalBody, aiReasoning) {
  const SENDER_EMAIL = config.senderEmail; // L'email verificata in SendGrid (test@aitaky.it)

  const htmlBody = `
    <div style="font-family: sans-serif; border: 1px solid #ddd; padding: 16px; border-radius: 8px;">
      <p><strong>Questa email Ã¨ stata smistata automaticamente dal sistema AI.</strong></p>
      <p style="background-color: #f5f5f5; padding: 12px; border-radius: 4px;">
        <strong>Motivazione AI:</strong> <em>${aiReasoning}</em>
      </p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 16px 0;">
      <h3>Email Originale</h3>
      <p><strong>Da:</strong> ${fromName} <${fromAddress}></p>
      <p><strong>Oggetto:</strong> ${subject}</p>
      <div style="border-left: 3px solid #ccc; padding-left: 1em; margin-top: 1em; color: #555;">
        <pre style="white-space: pre-wrap; font-family: inherit;">${originalBody}</pre>
      </div>
    </div>
  `;

  const msg = {
    to: to,
    from: SENDER_EMAIL, // Usa l'email configurata in .env e verificata in SendGrid
    subject: `[Smistato da AI] ${subject}`,
    html: htmlBody,
    replyTo: fromAddress, // Permette di rispondere direttamente al cliente originale
  };

  try {
    await sgMail.send(msg);
    console.log(`Email inoltrata con successo a ${to} tramite SendGrid.`);
  } catch (error) {
    console.error("Errore durante l'inoltro con SendGrid:", error.response?.body || error.message);
    throw error; // Rilancia l'errore per gestirlo nel chiamante
  }
}


================================================
FILE: server/utils/imapClient.js
================================================
// server/utils/imapClient.js
import Imap from 'node-imap';
import { simpleParser } from 'mailparser';

export async function fetchNewEmails(config) {
  const imap = new Imap({
    user: config.imapUsername,
    password: config.imapPassword,
    host: config.imapHost,
    port: config.imapPort,
    tls: true,
    tlsOpts: { rejectUnauthorized: false } // Mantiene il bypass del certificato
  });

  // Flag per assicurarsi che la connessione venga chiusa una sola volta e in modo sicuro
  let connectionState = 'connecting'; // 'connecting', 'ready', 'closed', 'error'
  const endConnection = (error = null) => {
    if (connectionState === 'closed') {
      return; // GiÃ  chiusa
    }
    try {
      if (imap.state !== 'disconnected') { // Tenta di chiudere solo se non Ã¨ giÃ  disconnesso
        imap.end();
      }
      connectionState = 'closed';
      if (error) {
        console.error('IMAP: Connection ended due to error, but trying to close gracefully:', error.message);
      } else {
        console.log('IMAP: Connection gracefully closed.');
      }
    } catch (e) {
      console.warn('IMAP: Error during imap.end() call (ignored, likely already closed):', e.message);
      connectionState = 'closed';
    }
  };

  return new Promise(async (resolve, reject) => {
    imap.once('ready', () => {
      connectionState = 'ready';
      console.log('IMAP: Connected successfully to the main client!');

      // *** MODIFICA QUI: Sposta il gestore degli errori del socket qui dentro ***
      // imap.client.socket dovrebbe essere definito una volta che la connessione Ã¨ "ready"
      if (imap.client && imap.client.socket) { // Aggiungi un controllo di sicurezza in piÃ¹
        imap.client.socket.on('error', (err) => {
          if (err.code === 'ECONNRESET') {
            console.warn('IMAP (Socket): Received ECONNRESET. This is often a benign post-operation disconnect.', err.message);
          } else {
            console.error('IMAP (Socket): Unhandled socket error:', err);
          }
          endConnection(err); // Assicurati che la connessione venga terminata
        });
      } else {
          console.warn('IMAP: imap.client or imap.client.socket was not available after ready event. Socket error handling might be incomplete.');
      }

      imap.openBox(config.imapMailbox, false, (err, box) => {
        if (err) {
          console.error('IMAP: Error opening mailbox:', err);
          endConnection(err); // Chiudi la connessione in caso di errore
          return reject(err); // Rifiuta la promise
        }
        console.log(`IMAP: Mailbox "${config.imapMailbox}" opened.`);

        imap.search(['UNSEEN'], (err, uids) => {
          if (err) {
            console.error('IMAP: Error searching for emails:', err);
            endConnection(err); // Chiudi la connessione in caso di errore
            return reject(err); // Rifiuta la promise
          }

          if (!uids || uids.length === 0) {
            console.log('IMAP: No new unseen emails.');
            endConnection(); // Chiudi la connessione
            return resolve([]); // Risolvi con array vuoto se non ci sono email
          }

          console.log(`IMAP: Found ${uids.length} unseen emails. Fetching them.`);

          const fetchPromises = []; // Array per contenere le Promises di ogni singola email

          const f = imap.fetch(uids, { bodies: '', struct: true, markSeen: false }); // markSeen: false per marcare manualmente

          f.on('message', (msg, seqno) => {
            let buffer = '';
            let currentUid; // Variabile per immagazzinare l'UID di questo specifico messaggio

            // Cattura l'UID appena gli attributi sono disponibili
            msg.once('attributes', (attrs) => {
              currentUid = attrs.uid;
            });

            // Crea una Promise per il parsing di questo singolo messaggio
            const messagePromise = new Promise(messageResolve => {
              msg.on('body', (stream) => {
                stream.on('data', (chunk) => {
                  buffer += chunk.toString('utf8');
                });
                stream.once('end', async () => {
                  try {
                    const parsed = await simpleParser(buffer);
                    messageResolve({ // Risolvi la Promise del messaggio con i dati parsati
                      uid: currentUid, // USA L'UID CATTURATO DAGLI ATTRIBUTI
                      messageId: parsed.messageId,
                      from: parsed.from?.text,
                      to: parsed.to?.text,
                      subject: parsed.subject,
                      text: parsed.text,
                      html: parsed.html,
                      date: parsed.date,
                      raw: buffer
                    });
                  } catch (parseErr) {
                    console.error('Error parsing email:', parseErr);
                    messageResolve(null); // Risolvi con null in caso di errore di parsing
                  }
                });
              });
            });
            fetchPromises.push(messagePromise); // Aggiungi la Promise di questo messaggio all'array
          });

          f.once('error', (fetchErr) => {
            console.error('IMAP: Fetch stream error:', fetchErr);
            endConnection(fetchErr);
            reject(fetchErr);
          });

          f.once('end', async () => {
            console.log('IMAP: Fetch stream ended. Waiting for all messages to parse.');
            const parsedEmails = (await Promise.all(fetchPromises)).filter(email => email !== null);
            console.log(`IMAP: Successfully parsed ${parsedEmails.length} emails.`);

            if (parsedEmails.length > 0) {
              const validUidsToMark = parsedEmails.map(e => e.uid).filter(uid => uid !== undefined && uid !== null);
              
              if (validUidsToMark.length > 0) {
                try {
                  await new Promise((flagResolve, flagReject) => {
                    imap.addFlags(validUidsToMark, ['\\Seen'], (flagErr) => {
                      if (flagErr) {
                        console.error('IMAP: Error marking emails as seen:', flagErr);
                        flagReject(flagErr); // Rifiuta la Promise interna se c'Ã¨ un errore
                      } else {
                        console.log('IMAP: Valid emails marked as seen.');
                        flagResolve(); // Risolvi la Promise interna
                      }
                    });
                  });
                } catch (addFlagsError) {
                  // Se addFlags fallisce, lo logghiamo ma non blocchiamo il flusso principale
                  console.error('IMAP: Failed to mark emails as seen due to:', addFlagsError);
                }
                endConnection();
                resolve(parsedEmails);
              } else {
                console.warn('IMAP: No valid UIDs found to mark as seen, but emails were parsed. Ending connection.');
                endConnection();
                resolve(parsedEmails);
              }
            } else {
              console.log('IMAP: No emails parsed successfully. Ending connection.');
              endConnection();
              resolve([]);
            }
          });
        });
      });
    });

    // Gestore generale per errori IMAP (cattura eventi che non sono legati a specifici stream di fetch)
    imap.once('error', (err) => {
      // Cattura ECONNRESET solo se la connessione non Ã¨ giÃ  gestita altrove.
      // A volte ECONNRESET avviene dopo la chiusura intenzionale del socket.
      if (!connectionEnded && ['ECONNRESET', 'ETIMEDOUT', 'EPIPE'].includes(err.code) && connectionState === 'ready') {
        console.warn(`IMAP: Received a non-critical connection error (${err.code}). Ignoring as a potential post-operation issue.`, err.message);
      } else if (!connectionEnded) { // Per altri errori non gestiti e se la connessione non Ã¨ chiusa
        console.error('IMAP: Global connection error:', err);
        reject(err);
      }
      endConnection(err); // Assicurati di chiudere la connessione
    });

    imap.once('end', () => {
      console.log('IMAP: Connection gracefully ended (IMAP end event).');
    });

    imap.connect();
  });
}


================================================
FILE: server/utils/mailProcessor.js
================================================
// server/utils/mailProcessor.js
import { fetchNewEmails } from './imapClient';
import { analyzeEmailWithAI } from './aiService';
import { sendEmail } from './emailSender';
import { getSupabaseAdminClient } from './supabaseAdmin';

export async function processNewIncomingEmails() {
  console.log('Starting email processing cycle...');
  const config = useRuntimeConfig();
  const supabaseAdmin = getSupabaseAdminClient();

  try {
    // 1. Leggi le nuove email dalla casella IMAP
    const incomingRawEmails = await fetchNewEmails(config);
    console.log(`Fetched ${incomingRawEmails.length} new emails from IMAP.`);

    for (const email of incomingRawEmails) {
      console.log(`Processing email from ${email.from} - Subject: ${email.subject}`);
      let emailRecordId = null; // Per tenere traccia dell'ID nel DB

      try {
        // 2. Salva l'email raw nel database
        const { data: savedEmail, error: saveError } = await supabaseAdmin.from('incoming_emails').insert([{
            sender: email.from,
            subject: email.subject,
            body_text: email.text,
            body_html: email.html,
            status: 'new',
            // created_at sarÃ  impostato automaticamente dal default del DB
        }]).select().single();

        if (saveError) throw new Error(`Supabase save error: ${saveError.message}`);
        emailRecordId = savedEmail.id;
        console.log(`Email saved to DB with ID: ${emailRecordId}`);

        // 3. Analizza l'email con l'AI (Gemini)
        const aiResult = await analyzeEmailWithAI(email.from, email.subject, email.text || email.html);
        
        // 4. Aggiorna l'email nel DB con i risultati dell'AI
        const { error: updateError } = await supabaseAdmin.from('incoming_emails').update({
            assigned_to_staff_id: aiResult.assigned_to_staff_id,
            ai_confidence_score: aiResult.ai_confidence_score,
            ai_reasoning: aiResult.ai_reasoning,
            status: aiResult.assigned_to_staff_id ? 'analyzed' : 'manual_review', // Se l'AI non assegna, richiede revisione manuale
        }).eq('id', emailRecordId);

        if (updateError) throw new Error(`Supabase AI update error: ${updateError.message}`);
        console.log(`AI analysis updated for email ID ${emailRecordId}. Assigned to staff: ${aiResult.assigned_to_staff_id || 'N/A'}`);

        // 5. Inoltra l'email al destinatario suggerito dall'AI
        if (aiResult.assigned_to_staff_id && aiResult.assignedStaffEmail) {
            try {
                await sendEmail(
                    aiResult.assignedStaffEmail,
                    email.from.split('<')[0].trim() || email.from, // Nome del mittente
                    email.from, // Indirizzo email del mittente originale
                    email.subject,
                    email.text || email.html, // Invia il testo o l'HTML originale
                    aiResult.ai_reasoning
                );

                // Aggiorna lo stato a 'forwarded' nel DB
                const { error: forwardStatusError } = await supabaseAdmin.from('incoming_emails').update({
                    status: 'forwarded',
                    // Non ci sono campi forwarded_to_email o forwarded_at nel tuo DB schema
                }).eq('id', emailRecordId);

                if (forwardStatusError) console.error(`Error updating forwarded status for ID ${emailRecordId}:`, forwardStatusError.message);
                console.log(`Email ID ${emailRecordId} successfully forwarded to ${aiResult.assignedStaffEmail}`);

            } catch (forwardError) {
                console.error(`Error forwarding email ID ${emailRecordId}:`, forwardError);
                // Aggiorna lo stato a 'forward_error' nel DB
                await supabaseAdmin.from('incoming_emails').update({
                    status: 'forward_error',
                    // Potresti aggiungere un campo 'error_details' per salvare l'errore completo
                }).eq('id', emailRecordId);
            }
        } else {
            console.warn(`Email ID ${emailRecordId} not assigned by AI or missing staff email. Status set to 'manual_review'.`);
        }

      } catch (innerError) {
        console.error(`Error processing single email (ID ${emailRecordId || 'N/A'}):`, innerError);
        // Se si verifica un errore prima di salvare l'email o durante il primo salvataggio,
        // emailRecordId potrebbe essere null. Gestisci di conseguenza.
        if (emailRecordId) {
            await supabaseAdmin.from('incoming_emails').update({
                status: 'processing_error',
                // error_message: innerError.message, // Se aggiungi un campo per i messaggi di errore
            }).eq('id', emailRecordId);
        }
      }
    }
  } catch (globalError) {
    console.error('Global error during email processing cycle:', globalError);
  }
  console.log('Email processing cycle finished.');
}


================================================
FILE: server/utils/supabaseAdmin.js
================================================
// server/utils/supabaseAdmin.js
import { createClient } from '@supabase/supabase-js';
import { useRuntimeConfig } from '#imports';

let supabaseAdminClient;

export function getSupabaseAdminClient() {
  if (!supabaseAdminClient) {
    const config = useRuntimeConfig();
    if (!config.public.supabaseUrl || !config.supabaseServiceRoleKey) {
      throw new Error('Missing Supabase URL or Service Role Key in runtimeConfig for admin client.');
    }
    // Usa la SERVICE_ROLE_KEY per operazioni lato server con piÃ¹ permessi
    supabaseAdminClient = createClient(config.public.supabaseUrl, config.supabaseServiceRoleKey, {
      auth: {
        persistSession: false, // Non persistere la sessione per un client server-side
      },
    });
  }
  return supabaseAdminClient;
}

